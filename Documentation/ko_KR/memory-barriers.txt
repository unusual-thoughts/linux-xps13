NOTE:
This is a version of Documentation/memory-barriers.txt translated into Korean.
This document is maintained by SeongJae Park <sj38.park@gmail.com>.
If you find any difference between this document and the original file or
a problem with the translation, please contact the maintainer of this file.

Please also note that the purpose of this file is to be easier to
read for non English (read: Korean) speakers and is not intended as
a fork.  So if you have any comments or updates for this file please
try to update the original English file first.

===================================
이 문서는
Documentation/memory-barriers.txt
의 한글 번역입니다.

역자： 박성재 <sj38.park@gmail.com>
===================================


			 =========================
			 리눅스 커널 메모리 배리어
			 =========================

저자: David Howells <dhowells@redhat.com>
      Paul E. McKenney <paulmck@linux.vnet.ibm.com>

목차:

 (*) 추상 메모리 액세스 모델.

     - 디바이스 오퍼레이션.
     - 보장사항들.

 (*) 메모리 배리어들이란 무엇인가?

     - 메모리 배리어의 종류들.
     - 메모리 배리어들에 대해 가정해선 안될 것들.
     - 데이터 의존성 배리어.
     - 컨트롤 의존성.
     - SMP 배리어 짝맞추기.
     - 메모리 배리어 시퀀스의 예.
     - 읽기 메모리 배리어 vs 로드 스페큘레이션.
     - 타동성

 (*) 명시적 커널 배리어들.

     - 컴파일러 배리어.
     - CPU 메모리 배리어.
     - MMIO 쓰기 배리어.

 (*) 암묵적 커널 메모리 배리어.

     - Acquiring 함수.
     - 인터럽트 비활성화 함수.
     - 슬립과 웨이크업 함수.
     - 그외의 함수들.

 (*) CPU 간 ACQUIRING 배리어의 효과.

     - Acquire vs 메모리 액세스.
     - Acquire vs I/O 액세스.

 (*) 메모리 배리어가 필요한 곳

     - 프로세서간 상호 작용.
     - 어토믹 오퍼레이션.
     - 디바이스 액세스.
     - 인터럽트.

 (*) 커널 I/O 배리어의 효과.

 (*) 가정되는 최소한의 실행 순서 모델.

 (*) CPU 캐시의 영향.

     - 캐시 일관성.
     - 캐시 일관성 vs DMA.
     - 캐시 일관성 vs MMIO.

 (*) CPU 들이 저지르는 일들.

     - 그리고 Alpha 가 있다.
     - 가상 머신 게스트.

 (*) 사용 예.

     - 순환식 버퍼.

 (*) 참고 문헌.


=======================
추상 메모리 액세스 모델
=======================

다음과 같은 추상화된 시스템 모델을 생각해 봅시다:

		            :                :
		            :                :
		            :                :
		+-------+   :   +--------+   :   +-------+
		|       |   :   |        |   :   |       |
		|       |   :   |        |   :   |       |
		| CPU 1 |<----->| Memory |<----->| CPU 2 |
		|       |   :   |        |   :   |       |
		|       |   :   |        |   :   |       |
		+-------+   :   +--------+   :   +-------+
		    ^       :       ^        :       ^
		    |       :       |        :       |
		    |       :       |        :       |
		    |       :       v        :       |
		    |       :   +--------+   :       |
		    |       :   |        |   :       |
		    |       :   |        |   :       |
		    +---------->| Device |<----------+
		            :   |        |   :
		            :   |        |   :
		            :   +--------+   :
		            :                :

각 CPU 는 메모리 액세스 오퍼레이션들을 생성해내는 프로그램을 실행합니다.
추상화된 CPU 에서, 메모리 오퍼레이션 순서는 매우 완화되어 있고, CPU 는
프로그램이 인과관계를 어기진 않고 관리된다고 보일 수만 있다면 메모리
오퍼레이션들을 자신이 원하는 어떤 순서대로든 재배치해 실행할 것입니다.
유사하게, 컴파일러 또한 프로그램의 정상적 동작을 망가뜨리지 않는 한도 내에서는
자신이 원하는대로 어떤 순서로든 명령어들을 재배치 할 것입니다.

따라서 위의 다어그램에서, 한 CPU가 수행하는 메모리 오퍼레이션의 효과는
오퍼레이션이 CPU 와 시스템의 다른 부분들 사이의 인터페이스(점선) 를 지나갈 때
시스템의 나머지 부분들에 전파됩니다.


예를 들어, 다음의 일련의 이벤트들을 생각해봅시다:

	CPU 1		CPU 2
	===============	===============
	{ A == 1; B == 2 }
	A = 3;		x = B;
	B = 4;		y = A;

메모리 시스템에 보여지게 될 중간의 액세스들은 다음의 총 24개 서로 다른 조합으로
재구성될 수 있습니다:

	STORE A=3,	STORE B=4,	y=LOAD A->3,	x=LOAD B->4
	STORE A=3,	STORE B=4,	x=LOAD B->4,	y=LOAD A->3
	STORE A=3,	y=LOAD A->3,	STORE B=4,	x=LOAD B->4
	STORE A=3,	y=LOAD A->3,	x=LOAD B->2,	STORE B=4
	STORE A=3,	x=LOAD B->2,	STORE B=4,	y=LOAD A->3
	STORE A=3,	x=LOAD B->2,	y=LOAD A->3,	STORE B=4
	STORE B=4,	STORE A=3,	y=LOAD A->3,	x=LOAD B->4
	STORE B=4, ...
	...

따라서 다음의 네가지 서로 다른 결과값의 조합이 보일 수 있습니다:

	x == 2, y == 1
	x == 2, y == 3
	x == 4, y == 1
	x == 4, y == 3


더욱이, 한 CPU 에 의해 메모리 시스템에 행해진 저장 동작들은 다른 CPU 의 읽기
동작들에 저장이 행해진 순서와 다른 순서로 읽혀질 수 있습니다.


예로, 이 일련의 이벤트들을 생각해 봅시다:

	CPU 1		CPU 2
	===============	===============
	{ A == 1, B == 2, C == 3, P == &A, Q == &C }
	B = 4;		Q = P;
	P = &B		D = *Q;

여기엔 분명한 데이터 의존성이 존재합니다. D 로 읽혀지는 값은 CPU 2 에서 P
로부터 읽혀진 주소값에 의존적입니다. 이벤트들이 완료되었을 때, 아래의 결과들이
가능합니다:

	(Q == &A) and (D == 1)
	(Q == &B) and (D == 2)
	(Q == &B) and (D == 4)

CPU 2 는 *Q 의 로드를 요청하기 전에 P 를 Q 에 넣기 때문에 D 에 C 를 집어넣는
일은 없음을 알아 두세요.


디바이스 오퍼레이션
-------------------

일부 디바이스들은 그들의 제어 인터페이스를 메모리 위치의 집합으로 제공합니다만,
해당 컨트롤 레지스터에 접근하는 순서는 매우 중요합니다.  예를 들어, 어드레스
포트 레지스터 (A) 와 데이터 포트 레지스터 (D) 를 통해 접근되는 내부 레지스터
집합을 갖는 이더넷 카드를 생각해 봅시다.  내부의 5번 레지스터를 읽으려면,
다음의 코드가 사용될 수 있을 겁니다:

	*A = 5;
	x = *D;

하지만 이건 다음의 두 조합 중 하나로 보여질 수 있을 겁니다:

	STORE *A = 5, x = LOAD *D
	x = LOAD *D, STORE *A = 5

두번째 조합은 데이터를 읽어온 _후에_ 주소를 설정하므로, 잘못된 동작을 일으킬
것입니다.


보장사항들
----------

CPU 에게 기대할 수 있는 최소한의 보장사항들이 일부 있습니다:

 (*) 어떤 CPU 든, 의존성이 존재하는 메모리 액세스들은 해당 CPU 자신에게
     있어서는 해당 순서 그대로 요청됩니다. 즉, 다음에 대해서는:

	Q = READ_ONCE(P); smp_read_barrier_depends(); D = READ_ONCE(*Q);

     CPU 는 다음과 같은 메모리 오퍼레이션들을 요청합니다:

	Q = LOAD P, D = LOAD *Q

     그리고 그 순서는 항상 지켜집니다.  대부분의 시스템에서,
     smp_read_barrier_depends() 는 아무일도 안합니다만, DEC Alpha 에서는
     필요합니다.  보통의 경우 당신은 smp_read_barrier_depends() 를 직접
     사용하는 대신 rcu_dereference() 같은 것들을 사용해야 할 겁니다.

 (*) 특정 CPU 내에서 겹쳐서 행해지는 로드와 스토어 들은 그 CPU 안에서는 순서가
     맞춰진 것으로 나타납니다.  즉, 다음에 대해서:

	a = READ_ONCE(*X); WRITE_ONCE(*X, b);

     CPU 는 다음의 메모리 오퍼레이션 배열만을 메모리에 요청할 것입니다:

	a = LOAD *X, STORE *X = b

     그리고 다음에 대해서는:

	WRITE_ONCE(*X, c); d = READ_ONCE(*X);

     CPU 는 오로지 다음의 명령만을 냅니다:

	STORE *X = c, d = LOAD *X

     (로드와 스토어는 같은 메모리 영역을 타겟으로 할 때에 겹쳐집니다).

그리고 _반드시_ 또는 _절대로_ 가정하거나 하지 말아야 하는 것들이 있습니다:

 (*) 컴파일러가 READ_ONCE() 나 WRITE_ONCE() 로 보호되지 않은 메모리 참조에 대해
     당신이 원하는 대로 할 것이라는 가정은 _절대로_ 해선 안됩니다.  그것들이
     없다면, 컴파일러는 컴파일러 배리어 섹션에서 다루게 될, 모든 "창조적인"
     변경들을 만들 권한을 가지게 됩니다.

 (*) 개별적인 로드와 스토어들이 주어진 순서대로 요청될 것이라는 가정은 _절대로_
     하지 말아야 합니다.  이 말은 즉:

	X = *A; Y = *B; *D = Z;

     는 다음의 순서들 중 어느 것이든 만들어질 수 있다는 의미입니다:

	X = LOAD *A,  Y = LOAD *B,  STORE *D = Z
	X = LOAD *A,  STORE *D = Z, Y = LOAD *B
	Y = LOAD *B,  X = LOAD *A,  STORE *D = Z
	Y = LOAD *B,  STORE *D = Z, X = LOAD *A
	STORE *D = Z, X = LOAD *A,  Y = LOAD *B
	STORE *D = Z, Y = LOAD *B,  X = LOAD *A

 (*) 겹치는 메모리 액세스들은 병합되거나 버려질 수 있음을 _반드시_ 가정해야
     합니다.  다음의 코드는:

	X = *A; Y = *(A + 4);

     다음의 인스트럭션 흐름 중 뭐든 될 수 있습니다:

	X = LOAD *A; Y = LOAD *(A + 4);
	Y = LOAD *(A + 4); X = LOAD *A;
	{X, Y} = LOAD {*A, *(A + 4) };

     그리고:

	*A = X; *(A + 4) = Y;

     는 다음 중 뭐든 가능합니다:

	STORE *A = X; STORE *(A + 4) = Y;
	STORE *(A + 4) = Y; STORE *A = X;
	STORE {*A, *(A + 4) } = {X, Y};

그리고 안티-보장사항들이 있습니다:

 (*) 이 보장사항들은 bitfields 에는 적용되지 않는데, 컴파일러들은 이것들을
     원자성 없는 read-modify-write 배열로 바꾸는 코드를 생성하기 때문입니다.
     병렬 알고리즘의 동기화에 bitfields 를 사용하려 하지 마십시오.

 (*) bitfields 가 여러 락으로 보호되는 경우라 하더라도, 주어진 bitfield 의 모든
     필드들은 하나의 락으로 보호되어야 합니다.  만약 한 bitfield 의 두 필드가
     서로 다른 락으로 보호된다면, 컴파일러의 원자성 없는 read-modify-write
     배열들은 한 필드에의 업데이트가 근처의 필드에도 영향을 끼칠 수 있습니다.

 (*) 이 보장사항들은 적절하게 정렬되고 크기가 잡힌 스칼라 변수들에 대해서만
     적용됩니다.  "적절하게 크기가 잡힌" 이라함은 현재로써는 "char", "short",
     "int" 그리고 "long" 과 같은 크기의 변수들을 의미합니다.  "적절하게 정렬된"
     은 자연적인 정렬을 의미하는데, 따라서 "char" 에 대해서는 아무 제약이 없고,
     "short" 에 대해서는 2바이트 정렬을, "int" 에는 4바이트 정렬을, 그리고
     "long" 에 대해서는 32-bit 시스템인지 64-bit 시스템인지에 따라 4바이트 또는
     8바이트 정렬을 의미합니다.  이 보장사항들은 C11 표준에서 소개되었으므로,
     C11 이전의 오래된 컴파일러(예를 들어, gcc 4.6) 를 사용할 때엔 주의하시기
     바랍니다.  표준에 이 보장사항들은 "memory location" 을 정의하는 3.14
     섹션에 다음과 같이 설명되어 있습니다:
     (역자: 인용문이므로 번역하지 않습니다)

	memory location
		either an object of scalar type, or a maximal sequence
		of adjacent bit-fields all having nonzero width

		NOTE 1: Two threads of execution can update and access
		separate memory locations without interfering with
		each other.

		NOTE 2: A bit-field and an adjacent non-bit-field member
		are in separate memory locations. The same applies
		to two bit-fields, if one is declared inside a nested
		structure declaration and the other is not, or if the two
		are separated by a zero-length bit-field declaration,
		or if they are separated by a non-bit-field member
		declaration. It is not safe to concurrently update two
		bit-fields in the same structure if all members declared
		between them are also bit-fields, no matter what the
		sizes of those intervening bit-fields happen to be.


=============================
메모리 배리어들이란 무엇인가?
=============================

앞에서 봤듯이, 개별적 메모리 오퍼레이션들은 실제로는 무작위적 순서로 수행될 수
있습니다만, 이것은 CPU 와 CPU 간 상호작용과 I/O 에 문제가 될 수 있습니다.
따라서 컴파일러와 CPU 가 바꾸는 순서에 개입할 수 있는 어떤 방법이 필요합니다.

메모리 배리어들이 그런 개입방법입니다.  메모리 배리어들은 배리어를 사이에 둔
양측의 메모리 오퍼레이션들 간에 부분적 순서가 존재하는 효과를 줍니다.

시스템의 CPU 들과 다른 디바이스들이 성능을 올리기 위해 재배치, 유예 그리고
메모리 오퍼레이션들의 조합; 투기적 로드; 투기적 브랜치 예측 그리고 다양한 캐싱
등의 다양한 트릭을 사용할 수 있기 때문에 이런 강제력은 중요합니다.  메모리
배리어들은 이런 트릭들을 무효로 하거나 억제하기 위해 사용되어져서 코드가 여러
CPU 와/또는 디바이스들 간의 상호작용을 제정신으로 다룰 수 있게 해줍니다.


메모리 배리어의 종류들
----------------------

메모리 배리어들은 네개의 기본 종류로 분류됩니다:

 (1) 쓰기 (또는 스토어) 메모리 배리어들.

     쓰기 메모리 배리어는 시스템의 다른 컴포넌트들에 해당 배리어 앞에 명시된
     모든 STORE 오퍼레이션들이 해당 배리어 뒤에 명시된 모든 STORE
     오퍼레이션들보다 먼저 수행된 것과 같이 보일 것을 보장합니다.

     쓰기 배리어는 스토어 오퍼레이션들만에 대한 부분적 순서 세우기입니다; 로드
     오퍼레이션들에 대해서는 어떤 영향도 끼치지 않습니다.

     CPU 는 시간의 흐름에 따라 메모리 시스템에 일련의 스토어 오퍼레이션들을
     하나씩 집어넣습니다.  모든 쓰기 배리어 이전의 스토어 오퍼레이션들은 그
     쓰기 배리어 뒤의 모든 스토어 오퍼레이션들보다 _전에_ 그 순서대로 행해질
     것입니다.

     [!] 쓰기 배리어들은 읽기 또는 데이터 의존성 배리어와 함께 짝을 맞춰
     사용되어져야만 함을 알아두세요; "SMP 배리어 짝맞추기" 서브섹션을
     참고하세요.


 (2) 데이터 의존성 배리어.

     데이터 의존성 배리어는 읽기 배리어의 보다 약한 형태입니다.  두개의 로드
     오퍼레이션이 있고 두번째 것이 첫번째 것의 결과에 의존하고 있을 때(예:
     첫번째 로드는 두번째 로드가 참조할 주소를 읽는 경우), 두번째 로드가 읽어올
     데이터는 첫번째 로드에 의해 그 주소가 얻어지기 전에 업데이트 되어 있음을
     분명히 하기 위해 데이터 의존성 배리어가 필요할 수 있습니다.

     데이터 의존성 배리어는 상호 의존적인 로드 오퍼레이션들 사이의 부분적 순서
     세우기입니다; 스토어 오퍼레이션들이나 독립적인 로드들, 또는 중복되는
     로드들에 대해서는 어떤 영향도 끼치지 않습니다.

     (1) 에서 언급했듯, 시스템의 다른 CPU 들은 해당 CPU 가 어떤 변수의 값을
     원하면 인식할 수 있는 메모리 시스템에 일련의 스토어 오퍼레이션들을
     집어넣고 있는 것으로 볼 수 있습니다.
     특정 변수에 관심을 두고 있는 CPU 가 요청하는 데이터 의존성 배리어는 그
     앞의 어떤 로드 오퍼레이션도 그 로드가 다른 CPU가 요청한 스토어
     오퍼레이션들과 겹치는 영역을 향한다면, 배리어가 완료되는 시점에서는 그
     전에 로드와 겹쳤던 모든 스토어 오퍼레이션들이 완료되어 있음을 보장해
     데이터 의존성 배리어 이후의 로드 오퍼레이션들은 그 스토어 오퍼레이션의
     결과를 볼 수 있게 보장합니다.

     이 순서 세우기 제약에 대한 다이어그램을 위해선 "메모리 배리어 배열의 예"
     서브섹션을 참고하시기 바랍니다.

     [!] 첫번째 로드는 반드시 _데이터_ 의존성을 가져야지 컨트롤 의존성을 가져야
     하는게 아님을 알아두십시오.  만약 두번째 로드를 위한 주소가 첫번째 로드에
     의존적이지만 그 의존성은 조건적이지 그 주소 자체를 가져오는게 아니라면,
     그것은 _컨트롤_ 의존성이고 완전한 리드 배리어나 그보다 강한 무엇이
     필요합니다. 더 자세한 내용을 위해서는 "컨트롤 의존성" 서브섹션을
     참고하시기 바랍니다.

     [!] 데이터 의존성 배리어는 보통 쓰기 배리어들과 함께 짝을 맞춰 사용되어야
     합니다; "SMP 배리어 짝맞추기" 서브섹션을 참고하세요.


 (3) 읽기 (또는 로드) 메모리 배리어들.

     읽기 배리어는 데이터 디펜던시의 기능에 추가로 배리어 이전에 명시된 모든
     LOAD 오퍼레이션들이 배리어 이후에 명시되는 모든 LOAD 오퍼레이션들보다 먼저
     행해진 것으로 시스템의 다른 컴포넌트들에 보여질 것을 보장합니다.

     읽기 배리어는 로드 오퍼레이션에 행해지는 부분적 순서 세우기입니다; 스토어
     오퍼레이션에 대해서는 어떤 영향도 끼치지 않습니다.

     읽기 메모리 배리어들은 데이터 의존성 배리어를 내장하므로 데이터 의존성
     배리어들을 대신할 수 있습니다.

     [!] 읽기 배리어들은 보통 쓰기 배리어들과 짝을 맞춰 사용되어야 합니다; "SMP
     배리어 짝맞추기" 서브섹션을 참고하세요.


 (4) 범용 메모리 배리어들.

     범용 메모리 배리어는 시스템의 나머지 컴포넌트들에 배리어보다 앞서 명시된
     모든 LOAD 와 STORE 오퍼레이션들이 배리어 이후에 명시된 모든 LOAD 와 STORE
     오퍼레이션들보다 먼저 수행된 것으로 시스템의 나머지 컴포넌트들에 보이게
     됨을 보장합니다.

     범용 메모리 배리어는 로드와 스토어 모두에 대한 부분적 순서 세우기입니다.

     범용 메모리 배리어는 읽기 메모리 배리어, 쓰기 메모리 배리어 모두를
     내장하므로, 각 배리어 모두를 대신할 수 있습니다.


그리고 약간의 묵시적인 변형들:

 (5) ACQUIRE 오퍼레이션들.

     이 오퍼레이션들은 단방향의 투과성 배리어처럼 동작합니다.  ACQUIRE
     오퍼레이션 이후의 모든 메모리 오퍼레이션들은 ACQUIRE 오퍼레이션 이후에
     일어난 것으로 시스템의 나머지 컴포넌트들에 보이게 될 것이 보장됩니다.
     LOCK 오퍼레이션과 smp_load_acquire() 오퍼레이션도 ACQUIRE 오퍼레이션의
     일종입니다.

     ACQUIRE 오퍼레이션 이전에 일어난 메모리 오퍼레이션들은 ACQUIRE 오퍼레이션
     완료 이후에 일어난 것처럼 보일 수도 있습니다.

     ACQUIRE 오퍼레이션은 거의 항상 RELEASE 오퍼레이션과 짝을 지어 사용되어야
     합니다.


 (6) RELEASE 오퍼레이션들.

     이것들도 단방향 투과성 배리어처럼 동작합니다.  RELEASE 오퍼레이션 이전의
     모든 메모리 오퍼레이션들은 RELEASE 오퍼레이션 이전에 완료된 것처럼
     시스템의 다른 컴포넌트들에 보여질 것이 보장됩니다.  UNLOCK 오퍼레이션들과
     smp_store_release() 오퍼레이션들도 RELEASE 오퍼레이션의 일종입니다.

     RELEASE 오퍼레이션 이후에 일어난 메모리 오퍼레이션들은 RELEASE
     오퍼레이션이 완료되기 전에 행해진 것처럼 보일 수 있습니다.

     ACQUIRE 와 RELEASE 오퍼레이션의 사용은 일반적으로 다른 메모리 배리어의
     필요성을 없앱니다 (하지만 "MMIO 쓰기 배리어" 서브섹션에서 설명되는 예외를
     알아두세요).  또한, RELEASE+ACQUIRE 조합은 전체 메모리 배리어처럼 동작할
     것을 보장하지 -않습니다-.  하지만, 어떤 변수에 ACQUIRE 오퍼레이션을 한
     이후에는 같은 변수에 대해 RELEASE 앞에서 수행된 메모리 액세스는 보여질
     것이 보장됩니다.  달리 말하자면, 주어진 변수의 크리티컬 섹션에서는, 해당
     변수에 대한 모든 이전 크리티컬 섹션에서의 액세스들이 완료되었을 것을
     보장합니다.

     즉, ACQUIRE 는 최소한의 "취득" 동작처럼, 그리고 RELEASE 는 최소한의 "공개"
     처럼 동작한다는 의미입니다.


메모리 배리어들은 두 CPU 간, 또는 CPU 와 디바이스 간에 상호작용의 가능성이 있을
때에만 필요합니다.  만약 어떤 코드에 그런 상호작용이 없을 것임이 보장된다면,
해당 코드에서는 메모리 배리어를 사용할 필요가 없습니다.


이것들은 _최소한의_ 보장사항들임을 알아두세요. 다른 아키텍쳐에서는 더 강력한
보장사항들을 제공할 수도 있습니다, 하지만 그런 보장사항들은 아키텍쳐와 무관한
코드에서는 성립하지 _않을수도_ 있습니다.


메모리 배리어들에 대해 가정해선 안될 것들
-----------------------------------------

리눅스 커널 메모리 배리어들이 보장하지 않는 것들이 일부 있습니다:

 (*) 메모리 배리어 이전에 명시된 어떤 메모리 액세스도 메모리 배리어 명령의 수행
     완료 시점까지 _완료_ 될 것이란 보장은 없습니다; 배리어가 하는 일은 CPU 의
     액세스 큐에 일부 해당되는 타입의 액세스들은 넘을 수 없는 선을 긋는 것으로
     이해할 수 있습니다.

 (*) 한 CPU 에서 메모리 배리어를 요청하는 것은 시스템의 다른 CPU 나 하드웨어에
     어떤 직접적인 영향을 끼친다는 보장은 존재하지 않습니다.  간접적인 영향은
     두번째 CPU 가 바라보는 첫번째 CPU 의 액세스들의 순서에 가해집니다, 하지만
     다음을 보세요:

 (*) 한 CPU 가 두번째 CPU 의 메모리 액세스들의 결과로 일어난 효과를 옳은
     순서대로 본다는 보장은 없습니다, _설령_ 두번째 CPU 가 메모리 배리어를
     사용한다 해도, 첫번째 CPU _또한_ 그에 맞는 메모리 배리어를 사용하지
     않는다면 말이죠 ("SMP 배리어 짝맞추기" 서브섹션을 참고하세요).

 (*) CPU 바깥의 하드웨어[*] 중 일부가 메모리 액세스들의 순서를 바꾸지 않는다는
     보장은 없습니다.  CPU 캐시 일관성 메커니즘은 메모리 배리어의 간접적 영향을
     CPU들 사이에 전파하긴 하지만, 순서대로 전파하지는 않을 수도 있습니다.

	[*] 버스 마스터링 DMA 와 일관성에 대해서는 다음을 참고하시기 바랍니다:

	    Documentation/PCI/pci.txt
	    Documentation/DMA-API-HOWTO.txt
	    Documentation/DMA-API.txt


데이터 의존성 배리어
--------------------

데이터 의존성 배리어의 사용이 필요한 영역은 약간 미묘하고 항상 그 필요가
분명하지도 않습니다.  설명을 위해 다음의 이벤트 시퀀스를 봅시다:

	CPU 1		      CPU 2
	===============	      ===============
	{ A == 1, B == 2, C == 3, P == &A, Q == &C }
	B = 4;
	<쓰기 배리어>
	WRITE_ONCE(P, &B)
			      Q = READ_ONCE(P);
			      D = *Q;

여기엔 분명한 데이터 의존성이 존재하고, 이 시퀀스가 끝났을 때, Q 는 &A 또는 &B
일 것이고, 따라서:

	(Q == &A) 는 (D == 1) 를,
	(Q == &B) 는 (D == 4) 를 의미합니다.

하지만!  CPU 2 의 P 인식은 자신의 B 인식 이전에 되었을 수도 있고, 따라서 다음의
상황이 가능합니다:

	(Q == &B) and (D == 2) ????

이게 일관성이나 인과 관계 유지에 실패한 것처럼 보일 수도 있겠지만, 그렇지
않습니다, 그리고 이 현상은 (DEC Alpha 와 같은) 여러 실제 CPU 에서 발견될 수
있습니다.

이걸 제대로 해결하기 위해, 데이터 의존성 배리어나 그보다 나은 것이 주소를
읽어올 때와 데이터를 읽어올 때 사이에 추가되어야만 합니다:

	CPU 1		      CPU 2
	===============	      ===============
	{ A == 1, B == 2, C == 3, P == &A, Q == &C }
	B = 4;
	<쓰기 배리어>
	WRITE_ONCE(P, &B);
			      Q = READ_ONCE(P);
			      <데이터 의존성 배리어>
			      D = *Q;

이것이 앞의 가정된 경우 두가지 중 하나만이 발생하고, 세번째 경우는 발생할 수
없도록 합니다.

의존적 쓰기에 대해서도 데이터 의존성 배리어가 만들어져야 합니다:

	CPU 1		      CPU 2
	===============	      ===============
	{ A == 1, B == 2, C = 3, P == &A, Q == &C }
	B = 4;
	<쓰기 배리어>
	WRITE_ONCE(P, &B);
			      Q = READ_ONCE(P);
			      <데이터 의존성 배리어>
			      *Q = 5;

이 데이터 의존성 배리어는 Q 로의 읽기가 *Q 로의 스토어와 순서를 맞추게
해줍니다.  이는 다음과 같은 결과를 막습니다:

	(Q == B) && (B == 4)

이런 패턴은 흔치 않음을 알아 두시기 바랍니다.  무엇보다, 의존성 순서 세우기의
요점은 데이터 구조로의 쓰기를 -방지-하는 것입니다, 그런 쓰기와 연관되는 값비싼
캐시 미스들과 함께요.  이 패턴은 흔치 않은 에러 조건을 기록하고 그런 기록이
사라지는 것을 막는데 사용될 수 있습니다.


[!] 대단히 비직관적인 이 상황은 분리된 캐시를 가진 기계들, 예를 들어 한 캐시
뱅크가 짝수번 캐시 라인을 처리하고 다른 뱅크는 홀수번 캐시 라인을 처리하는 경우
등에서 가장 잘 발생합니다.  포인터 P 는 홀수 번호의 캐시 라인에 있고, 변수 B 는
짝수 번호 캐시 라인에 있다고 생각해 봅시다.  그리고서, 읽기 작업을 하는 CPU 의
짝수번 뱅크가 매우 바쁜 사이 홀수번 뱅크는 놀고 있었다면, 포인터 P 는 새 값
(&B) 을, 그리고 변수 B 는 옛날 값 (2) 을 가지고 있는 걸 볼수도 있습니다.


데이터 의존성 배리어는 한 예로, RCU 시스템에서 매우 중요합니다.
include/linux/rcupdate.h 의 rcu_assign_pointer() 와 rcu_dereference() 를
참고하세요.  이건 RCU 된 포인터의 현재 타겟이 새로 수정된 타겟으로 바꾸는
작업에서 새로 수정된 타겟이 초기화가 안된채로 바꿔쳐진 것으로 보이는 문제가
없게 해줍니다.

더 많은 예를 위해선 "캐시 일관성" 서브섹션을 참고하세요.


컨트롤 의존성
-------------

로드-로드 컨트롤 의존성은 제대로 동작하기 위해 단순히 데이터 의존성 배리어를
치는 것만으로는 안되고, 전체 읽기 메모리 배리어를 필요로 합니다.  아래의 코드를
봅시다:

	q = READ_ONCE(a);
	if (q) {
		<데이터 의존성 배리어>  /* BUG: No data dependency!!! */
		p = READ_ONCE(b);
	}

실제 데이터 의존성이 아니라 CPU 가 분기 조건의 결과를 예상해서 실행 속도를 더
빠르게 만들 수도 있는 컨트롤 의존성이 존재하기 때문에, 이 코드는 원하던 대로
동작하지 않고, 다른 CPU 가 b 로부터의 로드 오퍼레이션이 a 의 로드
오퍼레이션보다 먼저 발생한 걸로 볼 수도 있게 합니다.  여기에 정말로 필요했던
건:

	q = READ_ONCE(a);
	if (q) {
		<읽기 배리어>
		p = READ_ONCE(b);
	}

하지만, 스토어 오퍼레이션은 추측되지 않습니다.  즉, 다음 예에서와 같이
로드-스토어 컨트롤 의존성이 존재하는 경우에는 순서가 제공-된다-는 의미입니다.

	q = READ_ONCE(a);
	if (q) {
		WRITE_ONCE(b, p);
	}

컨트롤 의존성들은 보통 다른 타입의 배리어들과 엮입니다.  그렇다곤 하나,
READ_ONCE() 는 선택 가능한게 아님을 반드시 기억해 두세요! READ_ONCE() 없이는,
컴파일러가 매우 비직관적인 결과를 초래하는 순서로 'a' 로부터의 로드를 다른 'a'
로부터의 로드와, 'b' 로의 스토어를 다른 'b' 로의 스토어와 조합해 버릴 수
있습니다.

이걸로 끝이 아닌게, 컴파일러가 변수 'a' 의 값이 항상 0이 아니라고 증명할 수
있다면, 앞의 예에서 "if" 문을 없애서 다음과 같이 최적화 할 수도 있습니다:

	q = a;
	b = p;  /* BUG: Compiler and CPU can both reorder!!! */

그러니 READ_ONCE() 를 반드시 사용하세요.

다음과 같이 "if" 문의 각 브랜치에 동일한 스토어에 대해 순서를 강제하고 싶은
경우가 있을 수 있습니다:

	q = READ_ONCE(a);
	if (q) {
		barrier();
		WRITE_ONCE(b, p);
		do_something();
	} else {
		barrier();
		WRITE_ONCE(b, p);
		do_something_else();
	}

안타깝지만, 현재의 컴파일러들은 높은 최적화 레벨에서는 이걸 다음과 같이
바꿔버립니다:

	q = READ_ONCE(a);
	barrier();
	WRITE_ONCE(b, p);  /* BUG: No ordering vs. load from a!!! */
	if (q) {
		/* WRITE_ONCE(b, p); -- moved up, BUG!!! */
		do_something();
	} else {
		/* WRITE_ONCE(b, p); -- moved up, BUG!!! */
		do_something_else();
	}

이제 'a' 에서의 로드와 'b' 로의 스토어 사이에는 조건적 관계가 없기 때문에 CPU
는 이들의 순서를 바꿀 수 있게 됩니다: 조건적 관계는 반드시 필요합니다, 그리고
모든 컴파일러 최적화가 이루어지고 난 후의 어셈블리 코드에서도 존재해야 합니다.
따라서, 이 예에서 순서를 지키기 위해서는 smp_store_release() 와 같은 명시적
메모리 배리어가 필요합니다:

	q = READ_ONCE(a);
	if (q) {
		smp_store_release(&b, p);
		do_something();
	} else {
		smp_store_release(&b, p);
		do_something_else();
	}

반대로, 명시적 메모리 배리어가 없다면, 이런 경우의 순서는 스토어 오퍼레이션들이
서로 다를 때에만, 예를 들어 다음과 같은 경우에 보장됩니다:

	q = READ_ONCE(a);
	if (q) {
		WRITE_ONCE(b, p);
		do_something();
	} else {
		WRITE_ONCE(b, r);
		do_something_else();
	}

처음의 READ_ONCE() 는 컴파일러가 'a' 의 값을 증명해내는 것을 막기 위해 여전히
필요합니다.

또한, 로컬 변수 'q' 를 가지고 하는 것에 대해 조심해야 합니다, 그러지 않으면
컴파일러는 그 값을 추측하고 또다시 필요한 조건관계를 없애버릴 수 있습니다.
예를 들면:

	q = READ_ONCE(a);
	if (q % MAX) {
		WRITE_ONCE(b, p);
		do_something();
	} else {
		WRITE_ONCE(b, r);
		do_something_else();
	}

만약 MAX 가 1 로 정의된 상수라면, 컴파일러는 (q % MAX) 는 0이란 것을 알아채고,
위의 코드를 아래와 같이 바꿔버릴 수 있습니다:

	q = READ_ONCE(a);
	WRITE_ONCE(b, p);
	do_something_else();

이렇게 되면, CPU 는 변수 'a' 로부터의 로드와 변수 'b' 로의 스토어 사이의 순서를
지켜줄 필요가 없어집니다.  barrier() 를 추가하고 싶겠지만, 그건 도움이
안됩니다.  조건 관계는 사라졌고, 배리어는 그걸 되돌리지 못합니다.  따라서, 이
순서를 지켜야 한다면, MAX 가 1 보다 크다는 것을, 대략 다음과 같이 분명히 해야
합니다:

	q = READ_ONCE(a);
	BUILD_BUG_ON(MAX <= 1); /* Order load from a with store to b. */
	if (q % MAX) {
		WRITE_ONCE(b, p);
		do_something();
	} else {
		WRITE_ONCE(b, r);
		do_something_else();
	}

'b' 로의 스토어들은 여전히 서로 다름을 알아두세요.  만약 그것들이 동일하면,
앞에서 이야기했듯, 컴파일러는 그 스토어 오퍼레이션들을 'if' 문 바깥으로
끄집어낼 수 있습니다.

또한 이진 조건문 평가에 너무 의존하지 않도록 조심해야 합니다.  다음의 예를
봅시다:

	q = READ_ONCE(a);
	if (q || 1 > 0)
		WRITE_ONCE(b, 1);

첫번째 조건은 거짓일 수 없고 두번째 조건은 항상 참이기 때문에, 컴파일러는 이
예를 다음과 같이 바꿔서 컨트롤 의존성을 없애버릴 수 있습니다:

	q = READ_ONCE(a);
	WRITE_ONCE(b, 1);

이 예는 컴파일러가 코드를 수정할 수 없다는 것을 분명히 해야 할 필요가 있다는
점을 강조합니다.  조금 일반적으로 말해서, READ_ONCE() 가 컴파일러에게 주어진
로드 오퍼레이션에 대해 코드를 만들도록 강제하긴 하지만, 컴파일러가 그 결과를
사용하도록 강제하지는 않습니다.

마지막으로, 컨트롤 의존성은 타동성을 제공하지 -않습니다-.  이건 x 와 y 가 둘 다
0 이라는 초기값을 가졌다는 가정 하의 두개의 예제로 보이겠습니다:

	CPU 0                     CPU 1
	=======================   =======================
	r1 = READ_ONCE(x);        r2 = READ_ONCE(y);
	if (r1 > 0)               if (r2 > 0)
	  WRITE_ONCE(y, 1);         WRITE_ONCE(x, 1);

	assert(!(r1 == 1 && r2 == 1));

이 두 CPU 예제에서는 assert() 의 조건은 결코 참일 수 없을 것입니다.  하지만,
만약 컨트롤 의존성이 타동성을 (실제로는 그러지 않지만) 보장한다면, 다음의 CPU
가 추가되면 관련된 조건을 보장할 겁니다:

	CPU 2
	=====================
	WRITE_ONCE(x, 2);

	assert(!(r1 == 2 && r2 == 1 && x == 2)); /* FAILS!!! */

하지만 컨트롤 의존성은 타동성을 제공하지 -않기- 때문에, 세개의 CPU 예제가 실행
완료된 후에 assert() 의 조건은 거짓일 겁니다.  세개의 CPU 예제가 순서를 지키길
원한다면, CPU 0 와 CPU 1 코드의 로드와 스토어 사이, "if" 문 바로 다음에
smp_mb()를 넣어야 합니다.  더 나아가서, 최초의 두 CPU 예제는 매우 취약하고
쓰이지 않아야만 합니다.

이 두개의 예제는 다음 논문에 나온 LB 와 WWC 리트머스 테스트들입니다:
http://www.cl.cam.ac.uk/users/pes20/ppc-supplemental/test6.pdf 와 이 사이트:
https://www.cl.cam.ac.uk/~pes20/ppcmem/index.html.

요약하자면:

  (*) 컨트롤 의존성은 앞의 로드들을 뒤의 스토어들에 대해 순서를 잡아줍니다.
      하지만, 그 외의 어떤 순서도 보장하지 -않습니다-: 앞의 로드와 뒤의 로드들
      사이에도, 앞의 스토어와 뒤의 어떤 것들 사이에도요.  이런 다른 형태의
      순서가 필요하다면, smp_rmb() 나 smp_wmb(), 또는 앞의 스토어들과 뒤의
      로드들 사이라면, smp_mb() 를 사용해야 할 겁니다.

  (*) "if" 문의 양 브랜치가 같은 변수에의 동일한 스토어들로 시작한다면, 그
      스토어들은 각 스토어 앞에 smp_mb() 를 넣거나 smp_store_release() 를
      사용해서 스토어를 하는 식으로 순서를 맞춰줘야 합니다.  컴파일러 최적화는
      이 경우에 barrier() 를 무시할 수도 있기 때문에 "if" 문의 양 브랜치의
      시작지점에 barrier() 를 넣는 것만으로는 충분하지 않음을 알아 두시기
      바랍니다.

  (*) 컨트롤 의존성은 앞의 로드와 뒤의 스토어 사이에 최소 한번의 런타임
      조건관계를 필요로 하며, 이 조건관계는 앞의 로드와 관계되어야 합니다.
      만약 컴파일러가 조건 관계를 최적화로 없앨 수 있다면, 순서도 최적화
      해버렸을 겁니다.  READ_ONCE() 와 WRITE_ONCE() 가 주어진 조건 관계를
      유지하는데 도움이 될 수 있으니 잘 사용해야 합니다.

  (*) 컨트롤 의존성을 위해선 컴파일러가 조건관계를 없애버리는 것을 막아야
      합니다.  컨트롤 의존성이 사라지지 않게 하는데 주의 깊은 READ_ONCE() 나
      atomic{,64}_read() 가 도움을 줄 수 있습니다.  더 많은 정보를 위해선
      "컴파일러 배리어" 섹션을 참고하시기 바랍니다.

  (*) 컨트롤 의존성은 보통 다른 타입의 배리어들과 엮입니다.

  (*) 컨트롤 의존성은 타동성을 제공하지 -않습니다-. 타동성이 필요하다면,
      smp_mb() 를 사용하세요.


SMP 배리어 짝맞추기
--------------------

CPU 간 상호작용을 할 때에는 일부 타입의 메모리 배리어는 항상 짝을 맞춰
사용되어야만 합니다.  적절하게 짝을 맞추지 못하면 거의 항상 에러를 유발합니다.

범용 배리어들은 타동성이 없을지라도 대부분의 다른 타입의 배리어들과도 짝을
맞추지만, 범용 배리어끼리 짝을 맞춥니다.  ACQUIRE 배리어는 RELEASE 배리어와
짝을 맞춥니다만, 범용 배리어를 포함해 다른 배리어들과도 짝을 맞출 수 있습니다.
쓰기 배리어는 데이터 의존성 배리어나 컨트롤 의존성, ACQUIRE 배리어, RELEASE
배리어, 읽기 배리어, 또는 범용 배리어와 짝을 맞춥니다.  비슷하게 읽기 배리어나
컨트롤 의존성, 또는 데이터 의존성 배리어는 쓰기 배리어나 ACQUIRE 배리어,
RELEASE 배리어, 또는 범용 배리어와 짝을 맞춥니다:

	CPU 1		      CPU 2
	===============	      ===============
	WRITE_ONCE(a, 1);
	<쓰기 배리어>
	WRITE_ONCE(b, 2);     x = READ_ONCE(b);
			      <읽기 배리어>
			      y = READ_ONCE(a);

또는:

	CPU 1		      CPU 2
	===============	      ===============================
	a = 1;
	<쓰기 배리어>
	WRITE_ONCE(b, &a);    x = READ_ONCE(b);
			      <데이터 의존성 배리어>
			      y = *x;

또는:

	CPU 1		      CPU 2
	===============	      ===============================
	r1 = READ_ONCE(y);
	<범용 배리어>
	WRITE_ONCE(y, 1);     if (r2 = READ_ONCE(x)) {
			         <implicit control dependency>
			         WRITE_ONCE(y, 1);
			      }

	assert(r1 == 0 || r2 == 0);

기본적으로, 읽기 배리어는 "더 약한" 타입일 순 있어도 항상 존재해야 합니다.

[!] 쓰기 배리어 이전의 스토어 오퍼레이션은 일반적으로 읽기 배리어나 데이터
의존성 배리어 뒤의 로드 오퍼레이션과 매치될 것이고, 반대도 마찬가지입니다:

	CPU 1                               CPU 2
	===================                 ===================
	WRITE_ONCE(a, 1);    }----   --->{  v = READ_ONCE(c);
	WRITE_ONCE(b, 2);    }    \ /    {  w = READ_ONCE(d);
	<쓰기 배리어>              \        <읽기 배리어>
	WRITE_ONCE(c, 3);    }    / \    {  x = READ_ONCE(a);
	WRITE_ONCE(d, 4);    }----   --->{  y = READ_ONCE(b);


메모리 배리어 시퀀스의 예
-------------------------

첫째, 쓰기 배리어들은 스토어 오퍼레이션들의 부분적 순서 세우기로 동작합니다.
아래의 일련의 이벤트들을 보세요:

	CPU 1
	=======================
	STORE A = 1
	STORE B = 2
	STORE C = 3
	<쓰기 배리어>
	STORE D = 4
	STORE E = 5

이 일련의 이벤트들은 일관적 메모리 시스템에 시스템의 나머지 요소들이
원소들끼리는 순서 없는, 집합 { STORE A, STORE B, STORE C } 가 역시
원소자들끼리의 순서 없는, 집합 { STORE D, STORE E } 보드 먼저 일어난 것으로
보이도록 전달됩니다:

	+-------+       :      :
	|       |       +------+
	|       |------>| C=3  |     }     /\
	|       |  :    +------+     }-----  \  -----> 시스템의 나머지 요소에
	|       |  :    | A=1  |     }        \/       보여지는 이벤트들
	|       |  :    +------+     }
	| CPU 1 |  :    | B=2  |     }
	|       |       +------+     }
	|       |   wwwwwwwwwwwwwwww }   <--- 여기서 쓰기 배리어가 배리어 앞의
	|       |       +------+     }        모든 스토어가 이후의 스토어가
	|       |  :    | E=5  |     }        나오기 전에 메모리 시스템에
	|       |  :    +------+     }        전달되도록 합니다
	|       |------>| D=4  |     }
	|       |       +------+
	+-------+       :      :
	                   |
	                   | CPU 1 에 의해 메모리 시스템에 전달되는
	                   | 일련의 스토어 오퍼레이션들
	                   V


둘째, 데이터 의존성 배리어는 데이터 의존적 로드 오퍼레이션들의 부분적 순서
세우기로 동작합니다.  다음 일련의 이벤트들을 보세요:

	CPU 1			CPU 2
	=======================	=======================
		{ B = 7; X = 9; Y = 8; C = &Y }
	STORE A = 1
	STORE B = 2
	<쓰기 배리어>
	STORE C = &B		LOAD X
	STORE D = 4		LOAD C (gets &B)
				LOAD *C (reads B)

여기에 별다른 개입이 없다면, CPU 1 의 쓰기 배리어에도 불구하고 CPU 2 는 CPU 1
의 이벤트들을 완전히 무작위적 순서로 인지하게 됩니다:

	+-------+       :      :                :       :
	|       |       +------+                +-------+  | CPU 2 에 인지되는
	|       |------>| B=2  |-----       --->| Y->8  |  | 업데이트 이벤트
	|       |  :    +------+     \          +-------+  | 시퀀스
	| CPU 1 |  :    | A=1  |      \     --->| C->&Y |  V
	|       |       +------+       |        +-------+
	|       |   wwwwwwwwwwwwwwww   |        :       :
	|       |       +------+       |        :       :
	|       |  :    | C=&B |---    |        :       :       +-------+
	|       |  :    +------+   \   |        +-------+       |       |
	|       |------>| D=4  |    ----------->| C->&B |------>|       |
	|       |       +------+       |        +-------+       |       |
	+-------+       :      :       |        :       :       |       |
	                               |        :       :       |       |
	                               |        :       :       | CPU 2 |
	                               |        +-------+       |       |
	    분명히 잘못된        --->  |        | B->7  |------>|       |
	    B 의 값 인지 (!)           |        +-------+       |       |
	                               |        :       :       |       |
	                               |        +-------+       |       |
	    로드된 X 의 값은    --->    \       | X->9  |------>|       |
	    B 의 정상적 값을             \      +-------+       |       |
	    예측하게 해야 한다            ----->| B->2  |       +-------+
	                                        +-------+
	                                        :       :


앞의 예에서, CPU 2 는 (B 의 값이 될) *C 의 값 읽기가 C 의 LOAD 뒤어 이어짐에도
B 가 7 이라는 결과를 얻습니다.

하지만, 만약 데이터 의존성 배리어가 C 의 로드와 *C (즉, B) 사이에 있었다면:

	CPU 1			CPU 2
	=======================	=======================
		{ B = 7; X = 9; Y = 8; C = &Y }
	STORE A = 1
	STORE B = 2
	<쓰기 배리어>
	STORE C = &B		LOAD X
	STORE D = 4		LOAD C (gets &B)
				<데이터 의존성 배리어>
				LOAD *C (reads B)

다음과 같이 됩니다:

	+-------+       :      :                :       :
	|       |       +------+                +-------+
	|       |------>| B=2  |-----       --->| Y->8  |
	|       |  :    +------+     \          +-------+
	| CPU 1 |  :    | A=1  |      \     --->| C->&Y |
	|       |       +------+       |        +-------+
	|       |   wwwwwwwwwwwwwwww   |        :       :
	|       |       +------+       |        :       :
	|       |  :    | C=&B |---    |        :       :       +-------+
	|       |  :    +------+   \   |        +-------+       |       |
	|       |------>| D=4  |    ----------->| C->&B |------>|       |
	|       |       +------+       |        +-------+       |       |
	+-------+       :      :       |        :       :       |       |
	                               |        :       :       |       |
	                               |        :       :       | CPU 2 |
	                               |        +-------+       |       |
	                               |        | X->9  |------>|       |
	                               |        +-------+       |       |
	  C 의 스토어 앞의       --->   \   ddddddddddddddddd   |       |
	  모든 이벤트 결과가             \      +-------+       |       |
	  뒤의 로드에게                   ----->| B->2  |------>|       |
	  보이게 강제한다                       +-------+       |       |
	                                        :       :       +-------+


세번째, 읽기 배리어는 로드 오퍼레이션들에의 부분적 순서 세우기로 동작합니다.
아래의 일련의 이벤트를 봅시다:

	CPU 1			CPU 2
	=======================	=======================
		{ A = 0, B = 9 }
	STORE A=1
	<쓰기 배리어>
	STORE B=2
				LOAD B
				LOAD A

CPU 1 은 쓰기 배리어를 쳤지만, 별다른 개입이 없다면 CPU 2 는 CPU 1 에서 행해진
이벤트의 결과를 무작위적 순서로 인지하게 됩니다.

	+-------+       :      :                :       :
	|       |       +------+                +-------+
	|       |------>| A=1  |------      --->| A->0  |
	|       |       +------+      \         +-------+
	| CPU 1 |   wwwwwwwwwwwwwwww   \    --->| B->9  |
	|       |       +------+        |       +-------+
	|       |------>| B=2  |---     |       :       :
	|       |       +------+   \    |       :       :       +-------+
	+-------+       :      :    \   |       +-------+       |       |
	                             ---------->| B->2  |------>|       |
	                                |       +-------+       | CPU 2 |
	                                |       | A->0  |------>|       |
	                                |       +-------+       |       |
	                                |       :       :       +-------+
	                                 \      :       :
	                                  \     +-------+
	                                   ---->| A->1  |
	                                        +-------+
	                                        :       :


하지만, 만약 읽기 배리어가 B 의 로드와 A 의 로드 사이에 존재한다면:

	CPU 1			CPU 2
	=======================	=======================
		{ A = 0, B = 9 }
	STORE A=1
	<쓰기 배리어>
	STORE B=2
				LOAD B
				<읽기 배리어>
				LOAD A

CPU 1 에 의해 만들어진 부분적 순서가 CPU 2 에도 그대로 인지됩니다:

	+-------+       :      :                :       :
	|       |       +------+                +-------+
	|       |------>| A=1  |------      --->| A->0  |
	|       |       +------+      \         +-------+
	| CPU 1 |   wwwwwwwwwwwwwwww   \    --->| B->9  |
	|       |       +------+        |       +-------+
	|       |------>| B=2  |---     |       :       :
	|       |       +------+   \    |       :       :       +-------+
	+-------+       :      :    \   |       +-------+       |       |
	                             ---------->| B->2  |------>|       |
	                                |       +-------+       | CPU 2 |
	                                |       :       :       |       |
	                                |       :       :       |       |
	  여기서 읽기 배리어는   ---->   \  rrrrrrrrrrrrrrrrr   |       |
	  B 의 스토어 이전의              \     +-------+       |       |
	  모든 결과를 CPU 2 에             ---->| A->1  |------>|       |
	  보이도록 한다                         +-------+       |       |
	                                        :       :       +-------+


더 완벽한 설명을 위해, A 의 로드가 읽기 배리어 앞과 뒤에 있으면 어떻게 될지
생각해 봅시다:

	CPU 1			CPU 2
	=======================	=======================
		{ A = 0, B = 9 }
	STORE A=1
	<쓰기 배리어>
	STORE B=2
				LOAD B
				LOAD A [first load of A]
				<읽기 배리어>
				LOAD A [second load of A]

A 의 로드 두개가 모두 B 의 로드 이후에 있지만, 서로 다른 값을 얻어올 수
있습니다:

	+-------+       :      :                :       :
	|       |       +------+                +-------+
	|       |------>| A=1  |------      --->| A->0  |
	|       |       +------+      \         +-------+
	| CPU 1 |   wwwwwwwwwwwwwwww   \    --->| B->9  |
	|       |       +------+        |       +-------+
	|       |------>| B=2  |---     |       :       :
	|       |       +------+   \    |       :       :       +-------+
	+-------+       :      :    \   |       +-------+       |       |
	                             ---------->| B->2  |------>|       |
	                                |       +-------+       | CPU 2 |
	                                |       :       :       |       |
	                                |       :       :       |       |
	                                |       +-------+       |       |
	                                |       | A->0  |------>| 1st   |
	                                |       +-------+       |       |
	  여기서 읽기 배리어는   ---->   \  rrrrrrrrrrrrrrrrr   |       |
	  B 의 스토어 이전의              \     +-------+       |       |
	  모든 결과를 CPU 2 에             ---->| A->1  |------>| 2nd   |
	  보이도록 한다                         +-------+       |       |
	                                        :       :       +-------+


하지만 CPU 1 에서의 A 업데이트는 읽기 배리어가 완료되기 전에도 보일 수도 있긴
합니다:

	+-------+       :      :                :       :
	|       |       +------+                +-------+
	|       |------>| A=1  |------      --->| A->0  |
	|       |       +------+      \         +-------+
	| CPU 1 |   wwwwwwwwwwwwwwww   \    --->| B->9  |
	|       |       +------+        |       +-------+
	|       |------>| B=2  |---     |       :       :
	|       |       +------+   \    |       :       :       +-------+
	+-------+       :      :    \   |       +-------+       |       |
	                             ---------->| B->2  |------>|       |
	                                |       +-------+       | CPU 2 |
	                                |       :       :       |       |
	                                 \      :       :       |       |
	                                  \     +-------+       |       |
	                                   ---->| A->1  |------>| 1st   |
	                                        +-------+       |       |
	                                    rrrrrrrrrrrrrrrrr   |       |
	                                        +-------+       |       |
	                                        | A->1  |------>| 2nd   |
	                                        +-------+       |       |
	                                        :       :       +-------+


여기서 보장되는 건, 만약 B 의 로드가 B == 2 라는 결과를 봤다면, A 에의 두번째
로드는 항상 A == 1 을 보게 될 것이라는 겁니다.  A 에의 첫번째 로드에는 그런
보장이 없습니다; A == 0 이거나 A == 1 의 결과를 보게 될 것입니다.


읽기 메모리 배리어 VS 로드 스페큘레이션
---------------------------------------

많은 CPU들이 로드를 추측적으로 합니다: 메모리에서 어떤 데이터를 로드해야 하게
될지 추측을 하고, 실제로 해당 데이터를 로드하는 인스트럭션을 아직 만나지
않았더라도 다른 로드 작업이 없어 버스가 사용되고 있지 않을 때, 그 데이터를
로드합니다.  이로 인해 실제 로드 인스트럭션은 CPU 가 이미 그 값을 가지고 있기
때문에 즉시 완료됩니다.

해당 CPU 는 실제로는 그 값이 필요치 않았다는 사실이 나올 수도 있는데 - 해당
로드 인스트럭션이 가 브랜치로 우회되거나 했을 수 있겠죠 - , 이 때에는 그 값을
버리거나 나중의 사용을 위해 캐시에 넣어둘 수 있습니다.

다음을 생각해 봅시다:

	CPU 1			CPU 2
	=======================	=======================
				LOAD B
				DIVIDE		} 나누기 명령은 일반적으로
				DIVIDE		} 긴 시간을 필요로 합니다
				LOAD A

는 이렇게 될 수 있습니다:

	                                        :       :       +-------+
	                                        +-------+       |       |
	                                    --->| B->2  |------>|       |
	                                        +-------+       | CPU 2 |
	                                        :       :DIVIDE |       |
	                                        +-------+       |       |
	나누기 하느라 바쁜       --->       --->| A->0  |~~~~   |       |
	CPU 는 A 의 LOAD 를                     +-------+   ~   |       |
	예측한다                                :       :   ~   |       |
	                                        :       :DIVIDE |       |
	                                        :       :   ~   |       |
	나누기가 끝나면       --->     --->     :       :   ~-->|       |
	CPU 는 해당 LOAD 를                     :       :       |       |
	즉각 완료한다                           :       :       +-------+


읽기 배리어나 데이터 의존성 배리어를 두번째 로드 직전에 놓는다면:

	CPU 1			CPU 2
	=======================	=======================
				LOAD B
				DIVIDE
				DIVIDE
				<읽기 배리어>
				LOAD A

예측으로 얻어지는 값은 사용된 배리어의 타입에 따라서 해당 값이 옳은지
검토하됩니다.  만약 해당 메모리 영역에 변화가 없었다면, 예측으로 얻어두었던
값이 사용됩니다:

	                                        :       :       +-------+
	                                        +-------+       |       |
	                                    --->| B->2  |------>|       |
	                                        +-------+       | CPU 2 |
	                                        :       :DIVIDE |       |
	                                        +-------+       |       |
	나누기 하느라 바쁜       --->       --->| A->0  |~~~~   |       |
	CPU 는 A 의 LOAD 를                     +-------+   ~   |       |
	예측한다                                :       :   ~   |       |
	                                        :       :DIVIDE |       |
	                                        :       :   ~   |       |
	                                        :       :   ~   |       |
	                                    rrrrrrrrrrrrrrrr~   |       |
	                                        :       :   ~   |       |
	                                        :       :   ~-->|       |
	                                        :       :       |       |
	                                        :       :       +-------+


하지만 다른 CPU 에서 업데이트나 무효화가 있었다면, 그 예측은 무효화되고 그 값은
다시 읽혀집니다:

	                                        :       :       +-------+
	                                        +-------+       |       |
	                                    --->| B->2  |------>|       |
	                                        +-------+       | CPU 2 |
	                                        :       :DIVIDE |       |
	                                        +-------+       |       |
	나누기 하느라 바쁜       --->       --->| A->0  |~~~~   |       |
	CPU 는 A 의 LOAD 를                     +-------+   ~   |       |
	예측한다                                :       :   ~   |       |
	                                        :       :DIVIDE |       |
	                                        :       :   ~   |       |
	                                        :       :   ~   |       |
	                                    rrrrrrrrrrrrrrrrr   |       |
	                                        +-------+       |       |
	예측성 동작은 무효화 되고    --->   --->| A->1  |------>|       |
	업데이트된 값이 다시 읽혀진다           +-------+       |       |
	                                        :       :       +-------+


타동성
------

타동성(transitivity)은 실제 컴퓨터 시스템에서 항상 제공되지는 않는, 순서
맞추기에 대한 상당히 직관적인 개념입니다.  다음의 예는
타동성을 보여줍니다:

	CPU 1			CPU 2			CPU 3
	=======================	=======================	=======================
		{ X = 0, Y = 0 }
	STORE X=1		LOAD X			STORE Y=1
				<범용 배리어>		<범용 배리어>
				LOAD Y			LOAD X

CPU 2 의 X 로드가 1을 리턴했고 Y 로드가 0을 리턴했다고 해봅시다.  이는 CPU 2 의
X 로드는 CPU 1 의 X 스토어 뒤에 이루어졌고 CPU 2 의 Y 로드는 CPU 3 의 Y 스토어
전에 이루어졌음을 의미합니다.  그럼 "CPU 3 의 X 로드는 0을 리턴할 수 있나요?"

CPU 2 의 X 로드는 CPU 1 의 스토어 이후에 이루어졌으니, CPU 3 의 X 로드는 1을
리턴하는게 자연스럽습니다.  이런 생각이 타동성의 한 예입니다: CPU A 에서 실행된
로드가 CPU B 에서의 같은 변수에 대한 로드를 뒤따른다면, CPU A 의 로드는 CPU B
의 로드가 내놓은 값과 같거나 그 이후의 값을 내놓아야 내놓아야 합니다.

리눅스 커널에서 범용 배리어의 사용은 타동성을 보장해 줍니다.  따라서, 앞의
예에서 CPU 2 의 X 로드가 1을, Y 로드는 0을 리턴했다면, CPU 3 의 X 로드는 반드시
1을 리턴합니다.

하지만, 읽기나 쓰기 배리어에 대해서는 타동성이 보장되지 -않습니다-.  예를 들어,
앞의 예에서 CPU 2 의 범용 배리어가 아래처럼 읽기 배리어로 바뀐 경우를 생각해
봅시다:

	CPU 1			CPU 2			CPU 3
	=======================	=======================	=======================
		{ X = 0, Y = 0 }
	STORE X=1		LOAD X			STORE Y=1
				<읽기 배리어>		<범용 배리어>
				LOAD Y			LOAD X

이 코드는 타동성을 지키지 않습니다: 이 예에서는, CPU 2 의 X 로드가 1을
리턴하고, Y 로드는 0을 리턴하지만 CPU 3 의 X 로드가 0을 리턴하는 것도 완전히
합법적입니다.

CPU 2 의 읽기 배리어가 자신의 읽기는 순서를 맞춰줘도, CPU 1 의 스토어를
맞춰준다고는 보장할 수 없다는게 핵심입니다.  따라서, 이 예제가 CPU 1 과 CPU 2
가 버퍼나 캐시를 공유하는 시스템에서 동작한다면, CPU 2 는 CPU 1 이 쓴 값에 좀
빨리 접근할 수 있을 것입니다.  따라서 CPU 1 과 CPU 2 의 접근으로 조합된 순서를
모든 CPU 가 동의할 수 있도록 하기 위해 범용 배리어가 필요합니다.

범용 배리어는 "글로벌 타동성"을 제공해서, 모든 CPU 들이 오퍼레이션들의 순서에
동의하게 할 것입니다.  반면, release-acquire 조합은 단지 "로컬 타동성" 만을
제공해서, 해당 조합이 사용된 CPU 들만이 해당 액세스들의 조합된 순서에 동의함이
보장됩니다.  예를 들어, 존경스런 Herman Hollerith 의 C 코드로 보면:

	int u, v, x, y, z;

	void cpu0(void)
	{
		r0 = smp_load_acquire(&x);
		WRITE_ONCE(u, 1);
		smp_store_release(&y, 1);
	}

	void cpu1(void)
	{
		r1 = smp_load_acquire(&y);
		r4 = READ_ONCE(v);
		r5 = READ_ONCE(u);
		smp_store_release(&z, 1);
	}

	void cpu2(void)
	{
		r2 = smp_load_acquire(&z);
		smp_store_release(&x, 1);
	}

	void cpu3(void)
	{
		WRITE_ONCE(v, 1);
		smp_mb();
		r3 = READ_ONCE(u);
	}

cpu0(), cpu1(), 그리고 cpu2() 는 smp_store_release()/smp_load_acquire() 쌍의
연결을 통한 로컬 타동성에 동참하고 있으므로, 다음과 같은 결과는 나오지 않을
겁니다:

	r0 == 1 && r1 == 1 && r2 == 1

나아가서, cpu0() 와 cpu1() 사이의 release-acquire 관계는 cpu0() 의 쓰기를
봐야만 하므로, 다음과 같은 결과도 나오지 않을 겁니다:

	r1 == 1 && r5 == 0

하지만, release-acquire 타동성은 동참한 CPU 들에만 적용되므로 cpu3() 에는
적용되지 않습니다.  따라서, 다음과 같은 결과가 가능합니다:

	r0 == 0 && r1 == 1 && r2 == 1 && r3 == 0 && r4 == 0

비슷하게, 다음과 같은 결과도 가능합니다:

	r0 == 0 && r1 == 1 && r2 == 1 && r3 == 0 && r4 == 0 && r5 == 1

cpu0(), cpu1(), 그리고 cpu2() 가 각자의 읽기와 쓰기를 순서대로 보게 되지만,
release-acquire 체인에 관여되지 않은 CPU 들은 그 순서에 이견을 가질 수도
있습니다.  이런 이견은 smp_load_acquire() 와 smp_store_release() 를 구현하는데
사용되는 완화된 메모리 배리어 인스트럭션들은 이전의 스토어들을 이후의 로드들에
항상 앞세울 필요는 없다는 사실에서 기인합니다.  이 말은 cpu3() 는 cpu0() 의 u
에의 스토어를 cpu1() 의 v 로부터의 로드 이후에 일어난 것으로 볼 수 있다는
뜻입니다, cpu0() 와 cpu1() 은 이 두 오퍼레이션이 의도된 순서대로 일어났음에
동의함에도 말이죠.

하지만, smp_load_acquire() 는 마술이 아님을 부디 기억하시기 바랍니다.  특히나,
이 함수는 단순히 그것의 인자를 순서대로 읽습니다.  이것은 어떤 특정한 값이 읽힐
것인지는 보장하지 -않습니다-.  따라서, 다음과 같은 결과도 가능합니다:

	r0 == 0 && r1 == 0 && r2 == 0 && r5 == 0

이런 결과는 어떤 것도 재배치 되지 않는 가상의 순차적 일관성 시스템에서도 일어날
수 있음을 기억해 두시기 바랍니다.

다시 말하지만, 당신의 코드가 글로벌 타동성을 필요로 한다면, 범용 배리어를
사용하십시오.


====================
명시적 커널 배리어들
====================

리눅스 커널은 서로 다른 수준으로 동작하는 다양한 배리어들을 가지고 있습니다:

  (*) 컴파일러 배리어.

  (*) CPU 메모리 배리어.

  (*) MMIO 쓰기 배리어.


컴파일러 배리어
---------------

리눅스 커널은 컴파일러가 메모리 액세스를 한쪽에서 다른 쪽으로 옮겨버리는 것을
막아주는 명시적인 컴파일러 배리어를 가지고 있습니다:

	barrier();

이건 범용 배리어입니다 -- barrier() 의 읽기-읽기 나 쓰기-쓰기 변종은 없습니다.
하지만, READ_ONCE() 와 WRITE_ONCE() 는 READ_ONCE() 또는 WRITE_ONCE() 로 특정된
액세스들에 대해서만 동작하는 barrier() 의 약화된 형태로 볼 수 있습니다.

barrier() 함수는 다음과 같은 효과를 갖습니다:

 (*) 컴파일러가 barrier() 뒤의 액세스들이 barrier() 앞의 액세스보다 먼저
     배치하지 못하게 합니다.  사용예를 들어보자면, 인터럽트 핸들러 코드와
     인터럽트된 코드 사이의 통신을 줄이기 위해 사용될 수 있습니다.

 (*) 루프 내에서, 컴파일러가 루프 조건에 사용된 변수를 매 이터레이션마다
     로드하도록 합니다.

READ_ONCE() 와 WRITE_ONCE() 함수는 싱글 쓰레드 코드에서는 문제 없지만 동시적
코드에서는 치명적일 수 있는 모든 최적화를 막습니다.  이런 류의 최적화들 예를
몇가지 들어보면 다음과 같습니다:

 (*) 컴파일러는 같은 변수에 대한 로드와 스토어를 재배치 할 수 있으며, 어떤
     경우에는 같은 변수에 대한 로드들을 재배치할 수도 있습니다.  이 말은 다음의
     코드가:

	a[0] = x;
	a[1] = x;

     x 의 예전 값이 a[1] 에, 새 값이 a[0] 에 있게 할 수 있다는 것입니다.
     컴파일러도 CPU 도 이런 일을 못하게 하려면 다음과 같이 해야 합니다:

	a[0] = READ_ONCE(x);
	a[1] = READ_ONCE(x);

     간단히 정리해서, READ_ONCE() 와 WRITE_ONCE() 는 여러 CPU 에서 하나의
     변수에 가해지는 액세스들에 캐시 일관성을 제공합니다.

 (*) 컴파일러는 같은 변수에 대한 연속적인 로드들을 병합할 수 있습니다.  그런
     병합 작업으로 컴파일러는 다음의 코드를:

	while (tmp = a)
		do_something_with(tmp);

     다음과 같이, 싱글 쓰레드 코드에서는 말이 되지만, 개발자의 의도와 전혀 맞지
     않는 방향으로 "최적화" 할 수 있습니다:

	if (tmp = a)
		for (;;)
			do_something_with(tmp);

     컴파일러가 이런 짓을 하지 못하게 하려면 READ_ONCE() 를 사용하세요:

	while (tmp = READ_ONCE(a))
		do_something_with(tmp);

 (*) 컴파일러는, 예를 들어 레지스터 사용량이 많아 컴파일러가 모든 데이터를
     레지스터에 담을 수 없는 경우, 변수를 다시 로드할 수 있습니다.  따라서
     컴파일러는 앞의 예에서 변수 'tmp' 를 최적화 할 수 있습니다:

	while (tmp = a)
		do_something_with(tmp);

     이 코드는 다음과 같이 싱글 쓰레드에서는 완벽하지만 동시성이 존재하는
     경우엔 치명적인 코드로 바뀔 수 있습니다:

	while (a)
		do_something_with(a);

     예를 들어, 최적화된 이 코드는 해당 변수가 다른 CPU 에 의해 "while" 문과
     do_something_with() 호출 사이에 바뀌어 do_something_with() 에 0을 넘길
     수도 있습니다.

     이번에도, 컴파일러가 그런 짓을 하는걸 막기 위해 READ_ONCE() 를 사용하세요:

	while (tmp = READ_ONCE(a))
		do_something_with(tmp);

     레지스터가 부족한 상황을 겪는 경우, 컴파일러는 tmp 를 스택에 저장해둘 수도
     있습니다.  이 저장과, 후에 다시 읽어들이는데 드는 오버헤드가 변수를 다시
     읽어들이는 이유입니다.  그렇게 하는건 싱글 쓰레드 코드에서는 안전하기
     때문에, 안전하지 않은 경우에는 컴파일러에게 직접 알려줘야 합니다.

 (*) 컴파일러는 그 값이 무엇일지 알고 있다면 로드를 아예 안할 수도 있습니다.
     예를 들어, 다음의 코드는 변수 'a' 의 값이 항상 0임을 증명할 수 있다면:

	while (tmp = a)
		do_something_with(tmp);

     이렇게 최적화 해버릴 수 있습니다:

	do { } while (0);

     이 변환은 싱글 쓰레드 코드에서는 도움이 되는데 로드와 브랜치를 제거했기
     때문입니다.  문제는 컴파일러가 'a' 의 값을 업데이트 하는건 현재의 CPU 하나
     뿐이라는 가정 위에서 증명을 했다는데 있습니다.  만약 변수 'a' 가 공유되어
     있다면, 컴파일러의 증명은 틀린 것이 될겁니다.  컴파일러는 그 자신이
     생각하는 것만큼 많은 것을 알고 있지 못함을 컴파일러에게 알리기 위해
     READ_ONCE() 를 사용하세요:

	while (tmp = READ_ONCE(a))
		do_something_with(tmp);

     하지만 컴파일러는 READ_ONCE() 뒤에 나오는 값에 대해서도 눈길을 두고 있음을
     기억하세요.  예를 들어, 다음의 코드에서 MAX 는 전처리기 매크로로, 1의 값을
     갖는다고 해봅시다:

	while ((tmp = READ_ONCE(a)) % MAX)
		do_something_with(tmp);

     이렇게 되면 컴파일러는 MAX 를 가지고 수행되는 "%" 오퍼레이터의 결과가 항상
     0이라는 것을 알게 되고, 컴파일러가 코드를 존재하지 않는 것처럼 최적화 하는
     것을 허용하게 됩니다.  ('a' 변수의 로드는 여전히 이루어질겁니다.)

 (*) 비슷하게, 컴파일러는 변수가 이미 저장하려 하는 값을 가지고 있다는 것을
     알면 스토어 자체를 제거할 수 있습니다.  이번에도, 컴파일러는 현재의 CPU
     만이 그 변수에 값을 쓰는 오로지 하나의 존재라고 생각하여 컴파일러가 공유된
     변수에 대해 잘못된 일을 하게 됩니다.  예를 들어, 다음과 같은 경우가
     있습니다:

	a = 0;
	/* 변수 a 에 스토어를 하지 않는 코드. */
	a = 0;

     컴파일러는 변수 'a' 의 값은 이미 0이라는 것을 알고, 따라서 두번째 스토어를
     삭제할 겁니다.  만약 다른 CPU 가 그 사이 변수 'a' 에 다른 값을 썼다면
     황당한 결과가 나올 겁니다.

     컴파일러가 그런 잘못된 추측을 하지 않도록 WRITE_ONCE() 를 사용하세요:

	WRITE_ONCE(a, 0);
	/* 변수 a 에 스토어를 하는 코드. */
	WRITE_ONCE(a, 0);

 (*) 컴파일러는 하지 말라고 하지 않으면 메모리 액세스들을 재배열 할 수
     있습니다.  예를 들어, 다음의 프로세스 레벨 코드와 인터럽트 핸들러 사이의
     상호작용을 생각해 봅시다:

	void process_level(void)
	{
		msg = get_message();
		flag = true;
	}

	void interrupt_handler(void)
	{
		if (flag)
			process_message(msg);
	}

     컴파일러가 process_level() 을 다음과 같이 코드를 변환하는 것을 막을 수단이
     여기엔 없고, 실제로, 이 변환은 싱글쓰레드에서라면 훌륭한 선택입니다:

	void process_level(void)
	{
		flag = true;
		msg = get_message();
	}

     이 두개의 문장 사이에 인터럽트가 발생한다면, interrupt_handler() 는 의미를
     알 수 없는 메세지를 받을 수도 있습니다.  이걸 막기 위해 다음과 같이
     WRITE_ONCE() 를 사용하세요:

	void process_level(void)
	{
		WRITE_ONCE(msg, get_message());
		WRITE_ONCE(flag, true);
	}

	void interrupt_handler(void)
	{
		if (READ_ONCE(flag))
			process_message(READ_ONCE(msg));
	}

     interrupt_handler() 안에서도 중첩된 인터럽트나 NMI 와 같이 인터럽트 핸들러
     역시 'flag' 와 'msg' 에 접근하는 또다른 무언가에 인터럽트 될 수 있다면
     READ_ONCE() 와 WRITE_ONCE() 래퍼들을 사용해야 함을 기억해 두세요.  만약
     그런 가능성이 없다면, interrupt_handler() 안에서는 문서화 목적이 아니라면
     READ_ONCE() 와 WRITE_ONCE() 는 필요치 않습니다.  (근래의 리눅스 커널에서
     중첩된 인터럽트는 보통 잘 일어나지 않음도 기억해 두세요, 실제로, 어떤
     인터럽트 핸들러가 인터럽트가 활성화된 채로 리턴하면 WARN_ONCE() 가
     동작합니다.)

     컴파일러는 READ_ONCE() 와 WRITE_ONCE() 이후의 READ_ONCE() 나 WRITE_ONCE(),
     barrier(), 또는 비슷한 것들을 담고 있지 않은 코드들을 움직일 것을 가정해야
     합니다.

     이 효과는 barrier() 를 통해서도 만들 수 있지만, READ_ONCE() 와
     WRITE_ONCE() 가 좀 더 안목 높은 선택입니다: READ_ONCE() 와 WRITE_ONCE()는
     컴파일러에 주어진 메모리 영역에 대해서만 최적화 가능성을 잊도록 하지만,
     barrier() 는 컴파일러가 지금까지 기계의 레지스터에 캐시해 놓은 모든 메모리
     영역의 값을 버려야 하게 하기 때문입니다.  물론, 컴파일러는 READ_ONCE() 와
     WRITE_ONCE() 가 일어난 순서도 지켜줍니다, CPU 는 물론 그러지 않겠지만요.

 (*) 컴파일러는 다음의 예에서와 같이 변수에의 스토어를 날조해낼 수도 있습니다:

	if (a)
		b = a;
	else
		b = 42;

     컴파일러는 아래와 같은 최적화로 브랜치를 줄일 겁니다:

	b = 42;
	if (a)
		b = a;

     싱글 쓰레드 코드에서는 이 최적화는 안전할 뿐 아니라 브랜치 갯수를
     줄여줍니다.  하지만 안타깝게도, 동시성이 있는 코드에서는 이 최적화는 다른
     CPU 가 'b' 를 로드할 때, -- 'a' 가 0이 아닌데도 -- 가짜인 값, 42를 보게
     되는 경우를 가능하게 합니다.  이걸 방지하기 위해 WRITE_ONCE() 를
     사용하세요:

	if (a)
		WRITE_ONCE(b, a);
	else
		WRITE_ONCE(b, 42);

     컴파일러는 로드도 날조해낼 수 있습니다.  일반적으로는 문제를 일으키지
     않지만, 캐시 라인 바운싱을 일으켜 성능과 확장성을 떨어뜨릴 수 있습니다.
     날조된 로드를 막기 위해선 READ_ONCE() 를 사용하세요.

 (*) 정렬된 메모리 주소에 위치한, 한번의 메모리 참조 인스트럭션으로 액세스
     가능한 크기의 데이터는 하나의 큰 액세스가 여러개의 작은 액세스들로
     대체되는 "로드 티어링(load tearing)" 과 "스토어 티어링(store tearing)"을
     방지합니다.  예를 들어, 주어진 아키텍쳐가 16-bit 스토어 인스트럭션을
     제공하고 7-bit immediate field 를 가지고 있다면, 컴파일러는 다음의 32-bit
     스토어 명령을 위해 두개의 16-bit store-immediate 명령을 사용하려 할겁니다:

	p = 0x00010002;

     GCC 는 스토어 할 상수값들을 만들고 또 그 값들을 스토어 하기 위해 두개가
     넘는 인스트럭션을 사용하게 되는 이런 종류의 최적화를 실제로 함을 부디
     기억해 주십시오.  따라서 이 최적화는 싱글 쓰레드 코드에서는
     성공적이겠습니다.  실제로, 최근에 발생한 (그리고 고쳐진) 버그는 GCC 가
     volatile 스토어에 비정상적으로 이 최적화를 사용하게 했습니다.  그런 버그가
     없더라도, WRITE_ONCE() 의 사용은 다음과 같이 스토어 티어링을 방지합니다:

	WRITE_ONCE(p, 0x00010002);

     Packed 구조체를 사용하는 것 역시 다음의 예처럼  로드 / 스토어 티어링을
     유발할 수 있습니다:

	struct __attribute__((__packed__)) foo {
		short a;
		int b;
		short c;
	};
	struct foo foo1, foo2;
	...

	foo2.a = foo1.a;
	foo2.b = foo1.b;
	foo2.c = foo1.c;

     READ_ONCE() 나 WRITE_ONCE() 래퍼들도 없고 volatile 마킹도 없기 때문에,
     컴파일러는 이 세개의 대입문을 32-bit 로드와 32-bit 스토어의 짝으로 변환할
     수 있습니다.  이는 'foo1.b' 의 값의 로드 티어링과 'foo2.b' 의 스토어
     티어링을 만들 것입니다.  READ_ONCE() 와 WRITE_ONCE() 가 이 예에서도
     티어링을 막을 수 있습니다:

	foo2.a = foo1.a;
	WRITE_ONCE(foo2.b, READ_ONCE(foo1.b));
	foo2.c = foo1.c;

그렇지만, volatile 로 마크된 변수에 대해서는 READ_ONCE() 와 WRITE_ONCE() 가
필요하지 않습니다.  예를 들어, 'jiffies' 는 volatile 로 마크되어 있기 때문에,
READ_ONCE(jiffies) 라고 할 필요가 없습니다.  이 이유는 READ_ONCE() 와
WRITE_ONCE() 가 실은 volatile 캐스팅으로 구현되어 있어서 인자가 이미 volatile
로 마크되어 있다면 또다른 효과를 내지는 않기 때문입니다.

이 컴파일러 배리어들은 CPU 에는 직접적 효과를 전혀 만들지 않기 때문에, 결국은
재배치가 일어날 수도 있음을 부디 기억해 두십시오.


CPU 메모리 배리어
-----------------

리눅스 커널은 다음의 여덟개 기본 CPU 메모리 배리어를 가지고 있습니다:

	타입		필수			SMP 조건적
	===============	=======================	===========================
	범용		mb()			smp_mb()
	쓰기		wmb()			smp_wmb()
	읽기		rmb()			smp_rmb()
	데이터 의존성	read_barrier_depends()	smp_read_barrier_depends()


데이터 의존성 배리어를 제외한 모든 메모리 배리어는 컴파일러 배리어를
포함합니다.  데이터 의존성은 추가적인 컴파일러 순서 세우기를 포함하지 않습니다.

방백: 데이터 의존성이 있는 경우, 컴파일러는 해당 로드를 올바른 순서로 일으킬
것으로 (예: `a[b]` 는 a[b] 를 로드 하기 전에 b 의 값을 먼저 로드한다)
예상됩니다만, C 사양에는 컴파일러가 b 의 값을 추측 (예: 1 과 같음) 해서
b 이전에 a 를 로드 하는 코드 (예: tmp = a[1]; if (b != 1) tmp = a[b]; ) 를
만들지 않아야 한다는 내용 같은 건 없습니다.  또한 컴파일러는 a[b] 를 로드한
이후에 b 를 또다시 로드할 수도 있어서, a[b] 보다 최신 버전의 b 값을 가질 수도
있습니다.  이 문제에 대한 의견의 일치는 아직  만들어지지 않았습니다만,
READ_ONCE() 매크로부터 보기 시작하는게 좋을 겁니다.

SMP 메모리 배리어들은 유니프로세서로 컴파일된 시스템에서는 컴파일러 배리어로
바뀌는데, 하나의 CPU 에서는 스스로 일관성을 유지하고, 겹치는 액세스들 역시
올바른 순서로 행해질 것으로 가정하기 때문입니다.  하지만, 아래의 "Virtual
Machine Guests" 서브섹션을 참고하십시오.

[!] SMP 메모리 배리어는 SMP 시스템에서의 공유메모리로의 접근을 순서 세워야 할
때, _반드시_ 사용되어야 함을 기억하세요, 다만 락을 대신 사용하는 것으로도
충분하긴 합니다.

필수 배리어들은 SMP 시스템에서도 UP 시스템에서도 불필요한 오버헤드를 갖기
때문에 SMP 효과를 통제하는데 사용되어선 안됩니다.  하지만, 느슨한 메모리 I/O
윈도우를 통한 액세스의 MMIO 효과를 통제할 때에는 사용될 수도 있습니다.  이
배리어들은 SMP 가 아닌 시스템에서도 사용될 수 있는데, 컴파일러와 CPU 의 메모리
오퍼레이션 재배치를 모두 막아서 메모리 오퍼레이션이 디바이스에 보이는 순서까지
영향을 주기 때문입니다.


몇개의 고급 배리어 함수들도 있습니다:

 (*) smp_store_mb(var, value)

     이 함수는 특정 변수에 특정 값을 대입하고 완전한 메모리 배리어를 칩니다.
     UP 컴파일에서는 컴파일러 배리어보다 더한 것을 친다고는 보장하지 않습니다.


 (*) smp_mb__before_atomic();
 (*) smp_mb__after_atomic();

     이것들은 값을 리턴하지 않는 (더하기, 빼기, 증가, 감소와 같은) 어토믹
     함수들, 특히 레퍼런스 카운팅에 사용될 때를 위한 함수들입니다.  이
     함수들은 메모리 배리어를 묵시적으로 사용하지는 않습니다.

     이것들은 값을 리턴하지 않는, 어토믹한 (set_bit 과 clear_bit 같은) 비트
     연산에도 사용될 수 있습니다.

     한 예로, 객체 하나를 무효화 하고 그 객체의 레퍼런스 카운트를 감소시키는
     다음 코드를 보세요:

	obj->dead = 1;
	smp_mb__before_atomic();
	atomic_dec(&obj->ref_count);

     이 코드는 객체의 업데이트된 death 마크가 레퍼런스 카운터 감소 동작
     *이전에* 보일 것을 분명하게 합니다.

     더 많은 정보를 위해선 Documentation/atomic_ops.txt 문서를 참고하세요.
     어디서 이것들을 사용해야 할지 궁금하다면 "Atomic operations" 서브섹션을
     참고하세요.


 (*) lockless_dereference();

     이 함수는 smp_read_barrier_depends() 데이터 의존성 배리어를 사용하는
     포인터 참조 래퍼 함수로 볼 수 있습니다.

     이건 rcu_dereference() 와도 객체의 라이프타임이 RCU 이외의 메커니즘으로
     관리된다는 점을 제외하면 유사한데, 예를 들면 객체가 시스템이 꺼질 때에만
     제거되는 경우 등입니다.  참고로, lockless_dereference() 는 일부 데이터
     구조에 RCU 와 함께 또는 단독으로 사용되고 있습니다.


 (*) dma_wmb();
 (*) dma_rmb();

     이것들은 CPU 와 DMA 가능한 디바이스에서 액세스 가능한 공유 메모리의 쓰기와
     읽기 동작에 대한 순서를 보장하기 위해 일관성 있는 메모리에서 사용하기 위한
     것들입니다.

     예를 들어, 디바이스와 메모리를 공유하고 디스크립터가 디바이스에 속해
     있는지 CPU 에 속해 있는지 알리기 위해 상태 값을 가지고, 새 디스크립터가
     사용 가능해졌을 때 알리는 초인종(doorbell) 을 사용하는 디바이스 드라이버를
     생각해 봅시다:

	if (desc->status != DEVICE_OWN) {
		/* 디스크립터를 소유하기 전의 데이터를 읽지 않음 */
		dma_rmb();

		/* 데이터를 읽고 씀 */
		read_data = desc->data;
		desc->data = write_data;

		/* 상태 업데이트 전 수정사항을 반영 */
		dma_wmb();

		/* 소유권을 수정 */
		desc->status = DEVICE_OWN;

		/* 디바이스에 알리기 전 MMIO 로 메모리의 동기화를 강제 */
		wmb();

		/* 디바이스에 새 디스크립터를 알림 */
		writel(DESC_NOTIFY, doorbell);
	}

     dma_rmb() 는 디바이스는 디스크립터로부터 데이터를 읽어오기 전에 소유권을
     내놓았음을 보장하게 하고, dma_wmb() 는 디바이스가 자신이 소유권을 가졌음을
     보기 전에 디스크립터에 데이터가 쓰였음을 분명히 하도록 합니다.  wmb() 는
     캐시 일관성이 없는 (cache incoherent) MMIO 영역에 쓰기를 시도하기 전에
     캐시 일관성이 있는 메모리 (cache coherent memory) 쓰기가 완료되었음을
     보장해주기 위해 필요합니다.

     일관성 있는 메모리에 대해 더 정보가 필요하면 Documentation/DMA-API.txt
     문서를 참고하세요.

MMIO 쓰기 배리어
----------------

리눅스 커널은 또한 memory-mapped I/O 쓰기를 위한 특별한 배리어도 가지고
있습니다:

	mmiowb();

이것은 필수 쓰기 배리어의 변종으로 순서가 취약한 I/O 영역에의 쓰기가 부분적으로
순서를 맞추도록 해줍니다.  이 함수의 효과는 CPU->하드웨어 인터페이스를 넘어서
실제 하드웨어에 몇몇 수준까지는 영향을 끼칩니다.

더 많은 정보를 위해선 "락 vs I/O 액세스" 서브섹션을 참고하세요.


=========================
암묵적 커널 메모리 배리어
=========================

리눅스 커널의 일부 다른 함수들은 메모리 배리어를 내장하고 있는데, 락과 스케쥴
관련 함수들이 대부분입니다.

여기선 _최소한의_ 보장을 설명합니다; 특정 아키텍쳐에서는 이 설명보다 더 많은
보장을 제공할 수도 있습니다만 그런 보장사항은 아키텍쳐 특정 코드에서만
구현됩니다.


ACQUIRING 함수
--------------

리눅스 커널은 다양한 락 구성체를 가지고 있습니다:

 (*) 스핀 락
 (*) R/W 스핀 락
 (*) 뮤텍스
 (*) 세마포어
 (*) R/W 세마포어

각 구성체마다 모든 경우에 "ACQUIRE" 오퍼레이션과 "RELEASE" 오퍼레이션의 변종이
존재합니다.  이 오퍼레이션들은 모두 적절한 배리어를 내포하고 있습니다:

 (1) ACQUIRE 오퍼레이션의 영향:

     ACQUIRE 후 요청되는 메모리 오퍼레이션들은 ACQUIRE 오퍼레이션이 완료된
     이후 완료됩니다.

     ACQUIRE 전에 요청된 메모리 오퍼레이션들은 ACQUIRE 오퍼레이션이 완료된 후에
     완료될 수도 있습니다.  smp_mb__before_spinlock() 이후 ACQUIRE 가 수행하는
     코드는 앞의 스토어들을 이후의 로드와 스토어들에 대해 순서 맞춥니다.  이건
     smp_mb() 보다 약한 제약임을 기억하세요!  smp_mb__before_spinlock() 은 많은
     아키텍쳐에서는 사실 아무것도 아닙니다.

 (2) RELEASE 오퍼레이션의 영향:

     RELEASE 전에 이슈된 메모리 오퍼레이션들은 RELEASE 오퍼레이션이 완료되기
     전에 완료됩니다.

     RELEASE 후에 요청된 메모리 오퍼레이션은 RELEASE 오퍼레이션 완료 전에
     완료될 수도 있습니다.

 (3) ACQUIRE vs ACQUIRE 영향:

     다른 ACQUIRE 오퍼레이션 이전에 요청된 모든 ACQUIRE 오퍼레이션은 앞의
     ACQUIRE 오퍼레이션 이전에 완료됩니다.

 (4) ACQUIRE vs RELEASE implication:

     RELEASE 오퍼레이션보다 먼저 요청된 ACQUIRE 오퍼레이션은 해당 RELEASE
     오퍼레이션보다 먼저 완료됩니다.

 (5) 실패한 조건적 ACQUIRE 영향:

     ACQUIRE 오퍼레이션의 일부 락 변종은 락을 곧바로 잡는데 실패하거나 락이
     획득 가능해지도록 기다리는 도중 시그널을 받거나 해서 실패할 수 있습니다.
     실패한 락은 어떤 배리어도 내포하지 않습니다.

[!] 참고: 락 ACQUIRE 와 RELEASE 가 단방향 배리어임으로 인한 결과 중 하나는
크리티컬 섹션 바깥의 인스트럭션의 영향이 크리티컬 섹션 내부로도 들어올 수
있다는 의미입니다.

RELEASE 이후에 요청되는 ACQUIRE 는 전체 메모리 배리어라 여겨지면 안되는데,
ACQUIRE 이전의 액세스가 ACQUIRE 이후에 수행될 수 있고, RELEASE 이후의 액세스가
RELEASE 이전에 수행될 수도 있으며, 그 두개의 액세스가 서로를 지나칠 수도 있기
때문입니다:

	*A = a;
	ACQUIRE M
	RELEASE M
	*B = b;

는 다음과 같이 될 수도 있습니다:

	ACQUIRE M, STORE *B, STORE *A, RELEASE M

ACQUIRE 와 RELEASE 가 락 획득과 해제라면, 그리고 락의 ACQUIRE 와 RELEASE 가
같은 락 변수에 대한 것이라면, 해당 락을 쥐고 있지 않은 다른 CPU 의 관점에는
똑같은 재배치가 일어나는 것을 볼 수 있습니다.  짧게 말해, ACQUIRE 와 RELEASE
두개 오퍼레이션의 순차적 실행은 전체 메모리 배리어로 생각되어선 -안됩니다-.

비슷하게, 앞의 반대 케이스인 RELEASE 와 ACQUIRE 두개 오퍼레이션의 순차적 실행
역시 전체 메모리 배리어를 내포하지 않습니다.  따라서, 크리티컬 섹션들의 CPU
수행은 RELEASE 와 ACQUIRE 를 가로지를 수 있으므로, 다음과 같은 코드는:

	*A = a;
	RELEASE M
	ACQUIRE N
	*B = b;

다음과 같이 수행될 수 있습니다:

	ACQUIRE N, STORE *B, STORE *A, RELEASE M

이런 재배치는 데드락을 일으킬 수도 있을 것으로 보일 수도 있습니다.  하지만,
그런 데드락의 조짐이 있다면 RELEASE 는 단순히 완료될 것이므로 데드락은 존재할
수 없습니다.

	어떻게 이게 동작하죠?

	우리가 이야기 하고 있는건 재배치를 하는 CPU 에 대한 이야기이지,
	컴파일러에 대한 것이 아니란 점이 핵심입니다.  컴파일러 (또는, 개발자)
	가 오퍼레이션들을 재배치하면, 데드락은 일어날 -수도 있습-니다.

	하지만 CPU 가 오퍼레이션들을 재배치 했다고 생각해 보세요.  어셈블리
	코드에서 언락이 락을 앞서는 경우를 생각해 봅시다.  CPU 는 단순히 뒤의
	락 오퍼레이션을 먼저 실행하려 하게 됩니다.  만약 데드락이 존재한다면,
	이 락 오퍼레이션은 단순히 스핀하며 계속해서 락을 시도합니다 (또는,
	한참 후에겠지만, 잠듭니다).  CPU 는 언젠가는 (어셈블리 코드에서는 락을
	앞섰던) 언락 오퍼레이션을 실행하는데, 이 언락 오퍼레이션은 잠재적
	데드락을 해결하고, 락 오퍼레이션도 뒤이어 성공하게 됩니다.

	하지만 만약 락이 잠을 자는 타입이었다면요?  그런 경우에 코드는
	스케쥴러로 들어가려 할 거고, 여기서 결국은 메모리 배리어를 만나게
	되는데, 이 메모리 배리어는 앞의 언락 오퍼레이션이 완료되도록 만들고,
	데드락은 이번에도 해결됩니다.  잠을 자는 언락 경쟁상황도 있을 수
	있겠습니다만, 락 관련 도구들은 그런 경쟁상황을 어떤 경우에도 제대로
	해결할 수 있도록 해야 합니다.

락과 세마포어는 유니 프로세서로 컴파일된 시스템에서의 순서에 대해 보장을 하지
않기 때문에, 그런 상황에서 인터럽트 비활성화 오퍼레이션과 함께가 아니라면 어떤
일에도 - 특히 I/O 액세스와 관련해서는 - 제대로 사용될 수 없을 겁니다.

"CPU 간 락킹 배리어 효과" 섹션도 참고하시기 바랍니다.


예를 들어, 다음과 같은 코드를 생각해 봅시다:

	*A = a;
	*B = b;
	ACQUIRE
	*C = c;
	*D = d;
	RELEASE
	*E = e;
	*F = f;

다음의 이벤트 시퀀스가 생길 수 있습니다:

	ACQUIRE, {*F,*A}, *E, {*C,*D}, *B, RELEASE

	[+] {*F,*A} 는 조합된 액세스를 의미합니다.

하지만 다음과 같은 건 불가능하죠:

	{*F,*A}, *B,	ACQUIRE, *C, *D,	RELEASE, *E
	*A, *B, *C,	ACQUIRE, *D,		RELEASE, *E, *F
	*A, *B,		ACQUIRE, *C,		RELEASE, *D, *E, *F
	*B,		ACQUIRE, *C, *D,	RELEASE, {*F,*A}, *E



인터럽트 비활성화 함수
----------------------

인터럽트를 비활성화 하는 함수 (ACQUIRE 와 동일) 와 인터럽트를 활성화 하는 함수
(RELEASE 와 동일) 는 컴파일러 배리어와 동일하게만 동작합니다.  따라서, 그런
상황에서는 메모리나 I/O 배리어가 필요하며, 그런 배리어들은 다른 방법으로
제공되어야만 합니다.


슬립과 웨이크업 함수
--------------------

글로벌 데이터에 표시된 이벤트에 의해 프로세스를 잠에 빠트리는 것과 깨우는 것은
두 조각의 데이터간의 상호작용으로 볼 수 있습니다: 해당 이벤트를 기다리는
태스크의 테스크 상태와 그 이벤트를 알리기 위해 사용되는 클로벌 데이터.
이것들이 옳은 순서대로 일어남을 분명히 하기 위해, 프로세스를 잠에 들게 하는
기능과 깨우는 기능은 몇가지 배리어를 내포합니다.

먼저, 잠을 재우는 쪽은 일반적으로 다음과 같은 이벤트 시퀀스를 따릅니다:

	for (;;) {
		set_current_state(TASK_UNINTERRUPTIBLE);
		if (event_indicated)
			break;
		schedule();
	}

set_current_state() 에 의해, 태스크 상태가 바뀐 후 범용 메모리 배리어가
자동으로 삽입됩니다:

	CPU 1
	===============================
	set_current_state();
	  smp_store_mb();
	    STORE current->state
	    <범용 배리어>
	LOAD event_indicated

set_current_state() 는 다음의 것들로 감싸질 수도 있습니다:

	prepare_to_wait();
	prepare_to_wait_exclusive();

이것들 역시 상태를 설정한 이후 범용 메모리 배리어가 쳐짐을 의미합니다.
앞의 전체 시퀀스는 다음과 같은 함수들로 한번에 수행 가능하며, 이것들은 모두
올바른 장소에 메모리 배리어를 삽입합니다:

	wait_event();
	wait_event_interruptible();
	wait_event_interruptible_exclusive();
	wait_event_interruptible_timeout();
	wait_event_killable();
	wait_event_timeout();
	wait_on_bit();
	wait_on_bit_lock();


두번째로, 깨우기를 수행하는 코드는 일반적으로 다음과 같을 겁니다:

	event_indicated = 1;
	wake_up(&event_wait_queue);

또는:

	event_indicated = 1;
	wake_up_process(event_daemon);

wake_up() 류에 의해 쓰기 메모리 배리어가 내포됩니다.  만약 그것들이 뭔가를
깨운다면요.  배리어는 태스크 상태가 설정되기 전에 수행되고, 따라서 이벤트를
알리기 위한 STORE 와 태스크 상태를 TASK_RUNNING 으로 설정하는 STORE 사이에
위치하게 됩니다.

	CPU 1				CPU 2
	===============================	===============================
	set_current_state();		STORE event_indicated
	  smp_store_mb();		wake_up();
	    STORE current->state	  <쓰기 배리어>
	    <범용 배리어>		  STORE current->state
	LOAD event_indicated

한번더 말합니다만, 이 쓰기 메모리 배리어는 만약 그것들이 정말로 뭔가를
깨운다면, 그때에만 존재합니다.  이걸 설명하기 위해, X 와 Y 는 모두 0 으로
초기화 되어 있다는 가정 하에 아래의 이벤트 시퀀스를 생각해 봅시다:

	CPU 1				CPU 2
	===============================	===============================
	X = 1;				STORE event_indicated
	smp_mb();			wake_up();
	Y = 1;				wait_event(wq, Y == 1);
	wake_up();			  load from Y sees 1, no memory barrier
					load from X might see 0

반면, 만약 깨우기가 행해졌다면, CPU 2 의 X 로드는 1 을 본다고 보장될 수 있을
겁니다.

사용 가능한 깨우기류 함수들로 다음과 같은 것들이 있습니다:

	complete();
	wake_up();
	wake_up_all();
	wake_up_bit();
	wake_up_interruptible();
	wake_up_interruptible_all();
	wake_up_interruptible_nr();
	wake_up_interruptible_poll();
	wake_up_interruptible_sync();
	wake_up_interruptible_sync_poll();
	wake_up_locked();
	wake_up_locked_poll();
	wake_up_nr();
	wake_up_poll();
	wake_up_process();


[!] 잠재우는 코드와 깨우는 코드에 내포되는 메모리 배리어들은 깨우기 이전의 여러
스토어들을 잠재우는 코드가 set_current_state() 를 호출한 이후에 저장된 값에
대한 로드는 순서를 맞추지 _않는다는_ 점을 기억하세요.  예를 들어, 잠재우는
코드가 다음과 같다면:

	set_current_state(TASK_INTERRUPTIBLE);
	if (event_indicated)
		break;
	__set_current_state(TASK_RUNNING);
	do_something(my_data);

그리고 깨우는 코드는 다음과 같다면:

	my_data = value;
	event_indicated = 1;
	wake_up(&event_wait_queue);

event_indecated 에의 변경이 재우는 코드에게 my_data 이후에 보일 것이라고 보장할
수 없습니다.  이런 경우에는 양쪽 코드 모두 각각의 데이터 액세스 사이에 메모리
배리어를 직접 쳐야 합니다.  따라서 앞의 재우는 코드는 다음과 같이:

	set_current_state(TASK_INTERRUPTIBLE);
	if (event_indicated) {
		smp_rmb();
		do_something(my_data);
	}

그리고 깨우는 코드는 다음과 같이 되어야 합니다:

	my_data = value;
	smp_wmb();
	event_indicated = 1;
	wake_up(&event_wait_queue);


그외의 함수들
-------------

그외의 배리어를 내포하는 함수들은 다음과 같습니다:

 (*) schedule() 과 그 유사한 것들이 전체 메모리 배리어를 내포합니다.


==============================
CPU 간 ACQUIRING 배리어의 효과
==============================

SMP 시스템에서의 락 도구들은 더욱 강력한 형태의 배리어를 제공합니다: 특정 락의
겹치는 사용 관련해서는 다른 CPU 들의 메모리 액세스 순서에 영향을 끼칩니다.


ACQUIRE VS 메모리 액세스
------------------------

다음의 예를 생각해 봅시다: 시스템은 두개의 스핀락 (M) 과 (Q), 그리고 세개의 CPU
를 가지고 있습니다; 여기에 다음의 이벤트 시퀀스가 발생합니다:

	CPU 1				CPU 2
	===============================	===============================
	WRITE_ONCE(*A, a);		WRITE_ONCE(*E, e);
	ACQUIRE M			ACQUIRE Q
	WRITE_ONCE(*B, b);		WRITE_ONCE(*F, f);
	WRITE_ONCE(*C, c);		WRITE_ONCE(*G, g);
	RELEASE M			RELEASE Q
	WRITE_ONCE(*D, d);		WRITE_ONCE(*H, h);

*A 로의 액세스부터 *H 로의 액세스까지가 어떤 순서로 CPU 3 에게 보여질지에
대해서는 각 CPU 에서의 각 락 사용에 의해 내포되어 있는 제약을 제외하고는 어떤
보장도 존재하지 않습니다.  예를 들어, 다음과 같은 순서로의 실행이 가능합니다:

	*E, ACQUIRE M, ACQUIRE Q, *G, *C, *F, *A, *B, RELEASE Q, *D, *H, RELEASE M

하지만 다음과 같은 경우는 있을 수 없습니다:

	*B, *C or *D preceding ACQUIRE M
	*A, *B or *C following RELEASE M
	*F, *G or *H preceding ACQUIRE Q
	*E, *F or *G following RELEASE Q



ACQUIRE VS I/O 액세스
----------------------

특정한 (특히 NUMA 가 관련된) 환경 하에서, 두개의 서로 다른 CPU 의 두 스핀락으로
만들어진 크리티컬 섹션에서 일어나는 I/O 액세스는, PCI 브릿지는 캐시 일관성
프로토콜과 합을 맞춰야 할 의무가 없으므로, 필요한 읽기 메모리 배리어를 요청할
수가 없어서, PCI 브릿지로 인해 재배열 되는 것으로 보일 수 있습니다.

예를 들어서:

	CPU 1				CPU 2
	===============================	===============================
	spin_lock(Q)
	writel(0, ADDR)
	writel(1, DATA);
	spin_unlock(Q);
					spin_lock(Q);
					writel(4, ADDR);
					writel(5, DATA);
					spin_unlock(Q);

는 PCI 브릿지에 의해 다음과 같이 보일 수 있습니다:

	STORE *ADDR = 0, STORE *ADDR = 4, STORE *DATA = 1, STORE *DATA = 5

그리고 이렇게 되면 하드웨어의 오동작을 일으킬 수 있습니다.


이런 경우엔 mmiowb() 를 스핀락을 놓기 전에 삽입해야 하는데, 예를 들면 다음과
같습니다:

	CPU 1				CPU 2
	===============================	===============================
	spin_lock(Q)
	writel(0, ADDR)
	writel(1, DATA);
	mmiowb();
	spin_unlock(Q);
					spin_lock(Q);
					writel(4, ADDR);
					writel(5, DATA);
					mmiowb();
					spin_unlock(Q);

이 코드는 CPU 1 에서 요청된 두개의 스토어가 PCI 브릿지에 CPU 2 에서 요청된
스토어들보다 먼저 보여짐을 보장합니다.


또한, 같은 기기에서 스토어를 이어 로드가 수행되면 로드는 로드가 수행되기 전에
스토어가 완료되기를 강제하므로 mmiowb() 의 필요가 없어집니다:

	CPU 1				CPU 2
	===============================	===============================
	spin_lock(Q)
	writel(0, ADDR)
	a = readl(DATA);
	spin_unlock(Q);
					spin_lock(Q);
					writel(4, ADDR);
					b = readl(DATA);
					spin_unlock(Q);


더 많은 정보를 위해선 Documenataion/DocBook/deviceiobook.tmpl 을 참고하세요.


=========================
메모리 배리어가 필요한 곳
=========================

평범한 시스템 운영 중에는, 설령 SMP 커널을 사용 중이라도 싱글 쓰레드로 동작하는
순차적 코드 조각들은 올바르게 동작하는 것으로 보일 것이기 때문에 메모리
오퍼레이션 재배치는 일반적으로 문제가 되지 않습니다.  하지만, 재배치가 문제가
_될 수 있는_ 네가지 환경이 있습니다:

 (*) 프로세서간 상호 작용.

 (*) 어토믹 오퍼레이션.

 (*) 디바이스 접근.

 (*) 인터럽트.


프로세서간 상호 작용
--------------------

두개 이상의 프로세서를 가진 시스템이 있다면, 시스템의 두개 이상의 CPU 는 동시에
같은 데이터에 대해 작업을 할 수 있습니다.  이는 동기화 문제를 일으킬 수 있고,
이 문제를 해결하는 일반적 방법은 락을 사용하는 것입니다.  하지만, 락은 상당히
비용이 비싸고, 따라서 만약 가능하기만 하다면 락을 사용하지 않고 일을 처리하는
것이 낫습니다.  그런 경우, 두 CPU 모두에 영향을 끼치는 오퍼레이션들은 오동작을
막기 위해 신중하게 순서가 맞춰져야 합니다.

예를 들어, R/W 세마포어의 느린 수행경로를 생각해 봅시다.  기다리는 프로세스는
세마포어의 대기 프로세스들 리스트에 자신도 링크되어 있는채로 세마포어에 줄지어
서 있습니다:

	struct rw_semaphore {
		...
		spinlock_t lock;
		struct list_head waiters;
	};

	struct rwsem_waiter {
		struct list_head list;
		struct task_struct *task;
	};

특정 대기 상태 프로세스를 깨우기 위해, up_read() 나 up_write() 함수는 다음과
같은 일을 해야 합니다:

 (1) 다음 대기 상태 프로세스 레코드는 어디있는지 알기 위해 이 대기 상태
     프로세스 레코드의 next 포인터를 읽습니다;

 (2) 대기 상태 프로세스의 task 구조체로의 포인터를 읽습니다;

 (3) 해당 대기 상태 프로세스가 세마포어를 획득했음을 알리기 위해 task
     포인터를 초기화 합니다;

 (4) 해당 태스크에 대해 wake_up_process() 를 호출합니다; 그리고

 (5) 해당 대기 상태 프로세스의 task 구조체를 잡고 있던 레퍼런스를 해제합니다.

달리 말하자면, 다음 이벤트 시퀀스를 수행해야 합니다:

	LOAD waiter->list.next;
	LOAD waiter->task;
	STORE waiter->task;
	CALL wakeup
	RELEASE task

그리고 만약 이 이벤트들이 다른 순서로 수행된다면, 오동작이 일어날 수 있습니다.

한번 세마포어의 대기줄에 들어갔고 세마포어 락을 놓았다면, 해당 대기 프로세스는
락을 다시는 잡지 않습니다; 대신 자신의 task 포인터가 초기화 되길 기다립니다.
레코드는 대기 프로세스의 스택에 있기 때문에, 지워진 task 포인터가 리스트의 next
포인터가 읽혀지기 _전에_ 읽혀진다면, 다른 CPU 는 해당 대기 프로세스를 시작해
버리고 up*() 함수가 next 포인터를 읽기 전에 대기 프로세스의 스택을 마구 건드릴
수 있습니다.

그렇게 되면 위의 이벤트 시퀀스에 어떤 일이 일어나는지 생각해 보죠:

	CPU 1				CPU 2
	===============================	===============================
					down_xxx()
					Queue waiter
					Sleep
	up_yyy()
	LOAD waiter->task;
	STORE waiter->task;
					Woken up by other event
	<preempt>
					Resume processing
					down_xxx() returns
					call foo()
					foo() clobbers *waiter
	</preempt>
	LOAD waiter->list.next;
	--- OOPS ---

이 문제는 세마포어 락의 사용으로 해결될 수도 있겠지만, 그렇게 되면 down_xxx()
함수가 불필요하게 깨어난 이후 스핀락을 또다시 얻어야만 합니다.

이걸 해결하는 방법은 범용 SMP 메모리 배리어를 추가하는 겁니다:

	LOAD waiter->list.next;
	LOAD waiter->task;
	smp_mb();
	STORE waiter->task;
	CALL wakeup
	RELEASE task

이 경우에, 배리어는 모든 배리어 이전의 메모리 액세스가 시스템의 나머지 CPU
들에게 배리어 뒤의 메모리 액세스보다 이전에 일어난 것으로 보이게 만듭니다.
배리어 이전의 메모리 액세스들이 배리어 명령 자체가 완료되는 시점까지
완료된다고는 보장하지 _않습니다_.

단일 프로세서 시스템 - 이게 문제가 되지 않을 - 에서 smp_mb() 는 그저 컴파일러가
실제로는 CPU 안에서의 순서를 바꾸거나 하지 않고 주어진 순서대로 명령을 내리도록
하는 컴파일러 배리어일 뿐입니다.  오직 하나의 CPU 만 있으므로, CPU 의 의존성
순서 로직이 그 외의 모든것들을 알아서 처리할 겁니다.


어토믹 오퍼레이션
-----------------

어토믹 오퍼레이션은 기술적으로는 프로세서간 상호작용으로 분류되며 그 중 일부는
전체 메모리 배리어를 내포하고 또 일부는 내포하지 않지만, 커널이 상당히 의존하는
그룹 중 하나입니다.

메모리의 어떤 상태를 수정하고 해당 상태에 대한 (예전의 또는 최신의) 정보를
리턴하는 어토믹 오퍼레이션은 모두 SMP-조건적 범용 메모리 배리어(smp_mb())를
실제 오퍼레이션의 앞과 뒤에 내포합니다.  이런 오퍼레이션은 다음의 것들을
포함합니다:

	xchg();
	atomic_xchg();			atomic_long_xchg();
	atomic_inc_return();		atomic_long_inc_return();
	atomic_dec_return();		atomic_long_dec_return();
	atomic_add_return();		atomic_long_add_return();
	atomic_sub_return();		atomic_long_sub_return();
	atomic_inc_and_test();		atomic_long_inc_and_test();
	atomic_dec_and_test();		atomic_long_dec_and_test();
	atomic_sub_and_test();		atomic_long_sub_and_test();
	atomic_add_negative();		atomic_long_add_negative();
	test_and_set_bit();
	test_and_clear_bit();
	test_and_change_bit();

	/* 성공했을 때 */
	cmpxchg();
	atomic_cmpxchg();		atomic_long_cmpxchg();
	atomic_add_unless();		atomic_long_add_unless();

이것들은 메모리 배리어 효과가 필요한 ACQUIRE 부류와 RELEASE 부류 오퍼레이션들을
구현할 때와 객체 소멸 시에 레퍼런스 카운터를 조정할 때 등에 사용됩니다.


다음의 오퍼레이션들은 메모리 배리어를 내포하지 _않기_ 때문에 문제가 될 수
있지만, RELEASE 부류의 오퍼레이션들과 같은 것들을 구현할 때 사용될 수도
있습니다:

	atomic_set();
	set_bit();
	clear_bit();
	change_bit();

이것들은 필요하다면 적절한 (예를 들면 smp_mb__before_atomic() 같은) 메모리
배리어가 명시적으로 함께 사용되어야 합니다.


아래의 것들도 메모리 배리어를 내포하지 _않기_ 때문에, 일부 환경에서는 (예를
들면 smp_mb__before_atomic() 과 같은) 명시적인 메모리 배리어 사용이 필요합니다.

	atomic_add();
	atomic_sub();
	atomic_inc();
	atomic_dec();

통계 데이터 생성을 위해 사용된다면, 통계 데이터 사이에 결합 관계가 존재하거나
하지 않는다면 메모리 배리어는 필요치 않을 겁니다.

객체의 수명을 관리하기 위해 레퍼런스 카운팅 목적으로 사용된다면, 레퍼런스
카운터는 락으로 보호되는 섹션에서만 조정되거나 호출하는 쪽이 이미 충분한
레퍼런스를 잡고 있을 것이기 때문에 메모리 배리어는 아마 필요 없을 겁니다.

만약 어떤 락을 구성하기 위해 사용된다면, 락 관련 동작은 일반적으로 작업을 특정
순서대로 진행해야 하므로 메모리 배리어가 필요할 수 있습니다.

기본적으로, 각 사용처에서는 메모리 배리어가 필요한지 아닌지 충분히 고려해야
합니다.

아래의 오퍼레이션들은 특별한 락 관련 동작들입니다:

	test_and_set_bit_lock();
	clear_bit_unlock();
	__clear_bit_unlock();

이것들은 ACQUIRE 류와 RELEASE 류의 오퍼레이션들을 구현합니다.  락 관련 도구를
구현할 때에는 이것들을 좀 더 선호하는 편이 나은데, 이것들의 구현은 많은
아키텍쳐에서 최적화 될 수 있기 때문입니다.

[!] 이런 상황에 사용할 수 있는 특수한 메모리 배리어 도구들이 있는데, 일부 CPU
에서 어토믹 인스트럭션의 사용은 전체 메모리 배리어를 내포하고 있어 어토믹
오퍼레이션과 메모리 배리어를 함께 사용하는 것은 불필요한 경우가 있을 수 있기
때문에, 해당 특수 메모리 배리어 도구들은 이런 경우 no-op 으로 처리됩니다.

더 많은 정보를 위해선 Documentation/atomic_ops.txt 를 참고하세요.


디바이스 액세스
---------------

많은 디바이스가 메모리에 매핑 될 수 있는데, 그렇게 되면 그것들은 CPU 에는 단지
메모리 영역의 집합처럼 보이게 됩니다.  그런 디바이스를 제어하기 위해서,
드라이버는 보통 정확히 올바른 순서로 올바른 메모리 액세스를 만들어야 합니다.

하지만, 영리한 CPU 나 영리한 컴파일러들은 만약 해당 CPU 나 컴파일러가
액세스들을 재배치 하고, 조합하거나 병합하는게 더 효율적이라 생각하게 되면
드라이버 코드의 조심스럽게 순서 맞춰진 액세스들이 디바이스에는 요청된 순서대로
도착하지 못할 수 있는 - 디바이스가 오동작을 하게 할 - 잠재적 문제 를
만들어냅니다.

리눅스 커널의 내부에서, I/O 는 반드시 어떻게 그런 액세스들을 적절히 순차적이게
만들 수 있는지 알고 있는, - inb() 나 writel() 과 같은 - 적절한 액세스 루틴을
통해 이루어져야 합니다.  이것들은 대부분의 부분에서 불필요한 메모리 배리어의
명시적 사용을 하기 때문에, 이것들이 쓰여야 할 곳은 다음의 두개 환경 정도입니다:

 (1) 일부 시스템에서 I/O 스토어는 모든 CPU 에 일관되게 순서 맞춰지지 않는데,
     따라서 _모든_ 범용 드라이버에는 락이 사용되어야만 하고 mmiowb() 는
     크리티컬 섹션을 빠져나오기 전에 꼭 호출되어야 합니다.

 (2) 만약 액세스 함수들이 완화된 메모리 액세스 속성을 갖는 I/O 메모리 윈도우를
     참고한다면, 순서를 맞추기 위해선 _필수_ 메모리 배리어들이 필요합니다.

더 많은 정보를 위해선 Documentation/DocBook/deviceiobook.tmpl 을 참고하십시오.


인터럽트
--------

드라이버는 자신의 인터럽트 서비스 루틴에 의해 인터럽트 당할 수 있기 때문에
드라이버의 이 두 부분은 각자의 디바이스 제어 또는 액세스 부분이 상호 간섭할 수
있습니다.

드라이버의 크리티컬한 오퍼레이션들은 모두 인터럽트 비활성화된 섹션에 집어넣거나
하는 식으로 로컬 인터럽트의 비활성화 (락의 한 형태) 를 통해 이런 상호 간섬을 -
최소한 부분적으로라도 - 줄여야 합니다.  드라이버의 인터럽트 루틴이 실행 중인
동안, 해당 드라이버의 코어는 다른 CPU 에서 수행중일 수도 있고, 인터럽트는
현재의 인터럽트가 처리되는 중에는 또다시 일어나지 못하도록 되어 있어서 인터럽트
핸들러는 그에 대해서는 락을 잡지 않아도 됩니다.

하지만, 어드레스 레지스터와 데이터 레지스터를 갖는 이더넷 카드를 다루는
드라이버를 생각해 봅시다.  만약 이 드라이버의 코어가 인터럽트가 비활성화된
상태의 카드와 이야기 중이고 드라이버의 인터럽트 핸들러가 호출되었다면:

	LOCAL IRQ DISABLE
	writew(ADDR, 3);
	writew(DATA, y);
	LOCAL IRQ ENABLE
	<interrupt>
	writew(ADDR, 4);
	q = readw(DATA);
	</interrupt>

만약 순서 규칙이 충분히 완화되어 있다면 데이터 레지스터에의 스토어는 어드레스
레지스터에 두번째로 행해지는 스토어 이후에 일어날 수도 있습니다:

	STORE *ADDR = 3, STORE *ADDR = 4, STORE *DATA = y, q = LOAD *DATA


만약 순서 규칙이 완화되어있다면, 묵시적이든 명시적이든 배리어가 사용되지
않았다면 인터럽트 비활성화 섹션에서 일어난 액세스가 바깥으로 새어서
인터럽트에서 일어난 액세스와 섞일 수도 있다고 - 그리고 그 반대도 - 가정해야만
합니다.

그런 섹션 안에서 일어나는 I/O 액세스들은 묵시적 I/O 배리어를 형성하는 엄격한
순서 규칙의 I/O 레지스터에의 동기화된 로드 오퍼레이션을 포함하기 때문에
일반적으로는 이런게 문제가 되지 않습니다.  만약 이걸로는 충분치 않다면 mmiowb()
가 명시적으로 사용될 필요가 있습니다.


하나의 인터럽트 루틴과 별도의 CPU 에서 수행중이며 서로 통신 중인 두 루틴
사이에도 비슷한 상황이 일어날 수 있습니다.  만약 그런 경우라면, 순서를 보장하기
위해 인터럽트 비활성화 락이 사용되어져야만 합니다.


======================
커널 I/O 배리어의 효과
======================

I/O 메모리에 접근할 때, 드라이버는 반드시 적절한 액세스 함수를 사용해야 합니다:

 (*) inX(), outX():

     이것들은 메모리 공간보다는 I/O 공간에 이야기를 하도록 의도하고
     만들어졌습니다만, 그건 CPU 마다 다른 컨셉입니다.  i386 과 x86_64
     프로세서들은 실제로 특별한 I/O 공간 액세스 사이클과 명령어를 가지고
     있습니다만, 다른 많은 CPU 들에는 그런 컨셉이 존재하지 않습니다.

     다른 것들 중, PCI 버스는 I/O 공간 컨셉을 정의하는데, 이는 - i386 과 x86_64
     같은 CPU 에서 - CPU 의 I/O 공간 컨셉으로 쉽게 매치됩니다.  하지만, 이는
     또한, 특히나 대체할 I/O 공간이 없는 CPU 에서는 CPU 의 메모리 맵의 가상 I/O
     공간으로 매치될 수도 있습니다.

     이 공간으로의 액세스는 (i386 등에서는) 완전하게 동기화 됩니다만, 중간의
     (PCI 호스트 브리지와 같은) 브리지들은 이를 완전히 보장하진 않을수
     있습니다.

     그것들은 상호간에 완전하게 순서가 보장됩니다.

     그것들은 다른 타입의 메모리와 I/O 오퍼레이션과의 순서는 완전하게
     보장되지는 않습니다.

 (*) readX(), writeX():

     이것들이 요청되는 CPU 에서 서로 완전히 순서가 맞춰지고 결합되지 않는지에
     대한 보장 여부는 이들이 액세스 하는 메모리 윈도우에 정의된 특성에 의해
     결정됩니다.  예를 들어, 최신의 i386 아키텍쳐 머신에서는 MTRR 레지스터로
     이를 조정합니다.

     일반적으로는, 프리페치 가능한 디바이스를 액세스 하는게 아니라면, 이것들은
     완전히 순서가 맞춰지고 결합되지 않게 보장될 겁니다.

     하지만, (PCI 브리지와 같은) 중간의 하드웨어는 만약 그것이 원한다면 집행을
     연기시킬 수 있습니다; 스토어 명령을 실제로 수행 시키는 것은(flush), 같은
     위치에서 로드를 하는 것으로 가능합니다[*], 하지만 PCI 의 경우는 같은
     디바이스나 환경 구성 영역에서의 로드만으로도 가능합니다.

     [*] 주의! 쓰여진 것과 같은 위치에서 로드를 시도하는 것은 오동작을 일으킬
         수도 있습니다 - 예로 16650 Rx/Tx 시리얼 레지스터를 생각해 보세요.

     프리페치 가능한 I/O 메모리가 사용되면, 스토어 명령들이 순서를 지키도록
     하기 위해선 mmiowb() 배리어가 필요할 수 있습니다.

     PCI 트랜잭션 사이의 상호작용에 대해 더 많은 정보를 위해선 PCI 명세서를
     참고하시기 바랍니다.

 (*) readX_relaxed(), writeX_relaxed()

     이것들은 readX() 와 writeX() 랑 비슷하지만, 더 약한 메모리 순서 보장을
     제공합니다.  구체적으로, 이것들은 일반적 메모리 액세스 (예: DMA 버퍼) 에도
     LOCK 이나 UNLOCK 오퍼레이션들에도 순서를 보장하지 않습니다.  순서가
     필요하다면, mmiowb() 배리어가 사용될 수 있습니다.  같은 주변 장치에의
     완화된 액세스는 각자에 대해서는 순서가 지켜짐을 알아 두시기 바랍니다.

 (*) ioreadX(), iowriteX()

     이것들은 inX()/outX() 나 readX()/writeX() 처럼 실제로 하는 액세스의 타입에
     적절하게 수행될 것입니다.


================================
가정되는 최소한의 실행 순서 모델
================================

컨셉적으로 CPU 는 주어진 프로그램에 대해 프로그램 그 자체에는 인과성을 지키는
것처럼 보이게 하지만 일반적으로는 순서를 거의 지켜주지 않는다고 가정되어야만
합니다.  (i386 이나 x86_64 같은) 일부 CPU 들은 (powerpc 나 frv 와 같은) 다른
것들에 비해 순서 재배치에 제약을 줍니다만, 아키텍쳐 종속적 코드 이외 부분에서는
순서에 대한 제약이 가장 완화된 경우 (DEC Alpha) 를 가정해야만 합니다.

이 말은 CPU 는 자신에게 주어지는 인스트럭션 스트림을 스트림 내의 한
인스트럭션이 앞의 인스트럭션에 종속적이라면 그 앞의 인스트럭션은 그 뒤의 종속적
인스트럭션이 실행되기 전에 완료[*]될 수 있어야 한다는 제약 외에는 자신이 원하는
순서대로 - 또는 심지어 병렬적으로 - 실행할 수 있음을 의미합니다; 이 제약은
인과성이 지켜짐을 의미합니다.

 [*] 일부 인스트럭션들은 하나 이상의 효과 - 조건 코드를 바꾼다던지, 레지스터나
     메모리를 바꾼다던지 -  를 내며, 다른 인스트럭션들은 서로 다른 효과에
     종속될 수도 있습니다.

CPU 는 최종적으로는 아무 효과도 만들지 않는 인스트럭션 시퀀스는 없애버릴 수도
있습니다.  예를 들어, 만약 두개의 연속되는 인스트럭션이 둘 다 같은 레지스터에
직접적인 값 (immediate value) 을 집어넣는다면, 첫번째 인스트럭션은 버려질 수도
있습니다.


비슷하게, 컴파일러는 역시 프로그램의 인과성만 지켜준다면 인스트럭션 스트림을
자신이 보기에 올바르다 생각하는대로 재배치 할 수 있습니다.


===============
CPU 캐시의 영향
===============

캐시된 메모리 오퍼레이션들이 시스템 전체에 어떻게 인지되는지는 CPU 와 메모리
사이에 존재하는 캐시와 시스템 상태의 일관성을 관리하는 메모리 코히런시 시스템에
의해 상당 부분 영향을 받습니다.

한 CPU 가 시스템의 다른 부분들과 캐시를 통해 상호작용한다면, 메모리 시스템은
CPU 의 캐시들과 메모리 배리어를 가져야만 하는데, 메모리 배리어들은 대부분의 CPU
와 그것의 캐시 사이 인터페이스에서 동작합니다 (메모리 배리어들은 논리적으로는
다음 그림의 점선에서 동작합니다):

	    <--- CPU --->         :       <----------- Memory ----------->
	                          :
	+--------+    +--------+  :   +--------+    +-----------+
	|        |    |        |  :   |        |    |           |    +--------+
	|  CPU   |    | Memory |  :   | CPU    |    |           |    |        |
	|  Core  |--->| Access |----->| Cache  |<-->|           |    |        |
	|        |    | Queue  |  :   |        |    |           |--->| Memory |
	|        |    |        |  :   |        |    |           |    |        |
	+--------+    +--------+  :   +--------+    |           |    |        |
	                          :                 | Cache     |    +--------+
	                          :                 | Coherency |
	                          :                 | Mechanism |    +--------+
	+--------+    +--------+  :   +--------+    |           |    |	      |
	|        |    |        |  :   |        |    |           |    |        |
	|  CPU   |    | Memory |  :   | CPU    |    |           |--->| Device |
	|  Core  |--->| Access |----->| Cache  |<-->|           |    |        |
	|        |    | Queue  |  :   |        |    |           |    |        |
	|        |    |        |  :   |        |    |           |    +--------+
	+--------+    +--------+  :   +--------+    +-----------+
	                          :
	                          :

특정 로드나 스토어는 해당 오퍼레이션을 요청한 CPU 의 캐시 내에서 동작을 완료할
수도 있기 때문에 해당 CPU 의 바깥에는 보이지 않을 수도 있지만, 다른 CPU 가
관심을 갖는다면 캐시 일관성 메커니즘이 해당 캐시라인을 접근하는 CPU 로 전달하고
해당 지역에 대한 오퍼레이션이 생길 때마다 그 영향을 전파시키기 때문에 해당
오퍼레이션은 여전히 메모리에 액세스를 실제로 한것처럼 나타날 것입니다.

CPU 코어는 프로그램의 인과성이 유지된다고만 여겨진다면 인스트럭션들을 어떤
순서로든 재배치해서 수행할 수도 있습니다.  일부 인스트럭션들은 로드나 스토어
오퍼레이션을 만드는데 이 오퍼레이션들은 이후 수행될 메모리 액세스 큐에 들어가게
됩니다.  코어는 이 오퍼레이션들을 해당 큐에 어떤 순서로든 원하는대로 넣을 수
있고, 다른 인스트럭션의 완료를 기다리도록 강제되기 전까지는 수행을 계속합니다.

메모리 배리어가 하는 일은 CPU 쪽에서의 액세스와 메모리 쪽에서의 액세스의 순서,
그리고 오퍼레이션의 효과가 시스템의 다른 관찰자들에게 행해진 것으로 전파되는
순서를 조정하는 것입니다.

[!] CPU 들은 항상 그들 자신의 로드와 스토어는 프로그램 순서대로 일어난 것으로
보기 때문에, 주어진 CPU 내에서는 메모리 배리어를 사용할 필요가 _없습니다_.

[!] MMIO 나 다른 디바이스 액세스들은 캐시 시스템을 우회할 수도 있습니다.  이는
디바이스가 액세스 되는 메모리 윈도우의 특성에 의해 결정될 수도 있고, CPU 가
가지고 있을 수도 있는 특수한 디바이스 통신 인스트럭션의 사용에 의해서 결정될
수도 있습니다.


캐시 일관성
-----------

하지만 삶은 앞에서 이야기한 것처럼 단순하지 않습니다: 캐시들은 일관적일 것으로
기대되지만, 그 일관성이 순서에도 적용될 거라는 보장은 없습니다.  한 CPU 에서
만들어진 변경 사항은 최종적으로는 시스템의 모든 CPU 에게 보여지게 되지만, 다른
CPU 들에게도 같은 순서로 보이게 될 거라는 보장은 없다는 뜻입니다.


두개의 CPU (1 & 2) 가 달려 있고, 각 CPU 는 두개의 데이터 캐시(CPU 1 은 A/B 를,
CPU 2 는 C/D 를 갖습니다)가 병렬로 연결되어 있는 시스템을 다룬다고 생각해
봅시다:

	            :
	            :                          +--------+
	            :      +---------+         |        |
	+--------+  : +--->| Cache A |<------->|        |
	|        |  : |    +---------+         |        |
	|  CPU 1 |<---+                        |        |
	|        |  : |    +---------+         |        |
	+--------+  : +--->| Cache B |<------->|        |
	            :      +---------+         |        |
	            :                          | Memory |
	            :      +---------+         | System |
	+--------+  : +--->| Cache C |<------->|        |
	|        |  : |    +---------+         |        |
	|  CPU 2 |<---+                        |        |
	|        |  : |    +---------+         |        |
	+--------+  : +--->| Cache D |<------->|        |
	            :      +---------+         |        |
	            :                          +--------+
	            :

이 시스템이 다음과 같은 특성을 갖는다 생각해 봅시다:

 (*) 홀수번 캐시라인은 캐시 A, 캐시 C 또는 메모리에 위치할 수 있음;

 (*) 짝수번 캐시라인은 캐시 B, 캐시 D 또는 메모리에 위치할 수 있음;

 (*) CPU 코어가 한개의 캐시에 접근하는 동안, 다른 캐시는 - 더티 캐시라인을
     메모리에 내리거나 추측성 로드를 하거나 하기 위해 - 시스템의 다른 부분에
     액세스 하기 위해 버스를 사용할 수도 있음;

 (*) 각 캐시는 시스템의 나머지 부분들과 일관성을 맞추기 위해 해당 캐시에
     적용되어야 할 오퍼레이션들의 큐를 가짐;

 (*) 해당 일관성 큐는 캐시에 이미 존재하는 라인에의 평범한 로드에 의해서는,
     심지어 큐의 오퍼레이션들이 이 로드의 결과에 영향을 끼칠 수 있다 할지라도,
     플러시 되지 않음.

이제, 첫번째 CPU 에서 두개의 쓰기 오퍼레이션을 만드는데, 해당 CPU 의 캐시에
요청된 순서로 오퍼레이션이 도달됨을 보장하기 위해 두 오퍼레이션 사이에 쓰기
배리어를 사용하는 상황을 상상해 봅시다:

	CPU 1		CPU 2		COMMENT
	===============	===============	=======================================
					u == 0, v == 1 and p == &u, q == &u
	v = 2;
	smp_wmb();			v 의 변경이 p 의 변경 이전에 보일 것을
					 분명히 함
	<A:modify v=2>			v 는 이제 캐시 A 에 유일하게 존재함
	p = &v;
	<B:modify p=&v>			p 는 이제 캐시 B 에 유일하게 존재함

쓰기 메모리 배리어는 시스템의 다른 CPU 들이 쓰기 배리어를 사용한 CPU 의 캐시가
올바른 순서로 업데이트 된 것으로 인지하게 만듭니다.  하지만 이제 두번째 CPU 가
그 값들을 읽으려 하는 상황을 생각해 봅시다:

	CPU 1		CPU 2		COMMENT
	===============	===============	=======================================
	...
			q = p;
			x = *q;

위의 두개의 읽기 오퍼레이션은 예상된 순서로 일어나지 못할 수 있는데, 두번째 CPU
의 한 캐시에 다른 캐시 이벤트가 발생해 v 를 담고 있는 캐시라인의 해당 캐시에의
업데이트가 지연되는 사이, p 를 담고 있는 캐시라인은 두번째 CPU 의 다른 캐시에
업데이트 되어버렸을 수 있기 때문입니다.

	CPU 1		CPU 2		COMMENT
	===============	===============	=======================================
					u == 0, v == 1 and p == &u, q == &u
	v = 2;
	smp_wmb();
	<A:modify v=2>	<C:busy>
			<C:queue v=2>
	p = &v;		q = p;
			<D:request p>
	<B:modify p=&v>	<D:commit p=&v>
			<D:read p>
			x = *q;
			<C:read *q>	캐시에 업데이트 되기 전의 v 를 읽음
			<C:unbusy>
			<C:commit v=2>

기본적으로, 두개의 캐시라인 모두 CPU 2 에 최종적으로는 업데이트 될 것이지만,
별도의 개입 없이는, 업데이트의 순서가 CPU 1 에서 만들어진 순서와 동일할
것이라는 보장은 없습니다.


여기에 개입하기 위해선, 데이터 의존성 배리어나 읽기 배리어를 로드 오퍼레이션들
사이에 넣어야 합니다.  이렇게 함으로써 캐시가 다음 리퀘스트를 처리하기 전에
일관성 큐를 처리하도록 강제하게 됩니다.

	CPU 1		CPU 2		COMMENT
	===============	===============	=======================================
					u == 0, v == 1 and p == &u, q == &u
	v = 2;
	smp_wmb();
	<A:modify v=2>	<C:busy>
			<C:queue v=2>
	p = &v;		q = p;
			<D:request p>
	<B:modify p=&v>	<D:commit p=&v>
			<D:read p>
			smp_read_barrier_depends()
			<C:unbusy>
			<C:commit v=2>
			x = *q;
			<C:read *q>	캐시에 업데이트 된 v 를 읽음


이런 부류의 문제는 DEC Alpha 프로세서들에서 발견될 수 있는데, 이들은 데이터
버스를 좀 더 잘 사용해 성능을 개선할 수 있는 분할된 캐시를 가지고 있기
때문입니다.  대부분의 CPU 는 한 읽기 오퍼레이션의 메모리 액세스가 다른 읽기
오퍼레이션에 의존적이라면 데이터 의존성 배리어를 내포시킵니다만, 모두가 그런건
아니기 때문에 여기에 의존해선 안됩니다.

다른 CPU 들도 분할된 캐시를 가지고 있을 수 있습니다만 평범한 메모리 액세스를
위한 다양한 캐시렛 사이의 조정이 필요합니다.  Alpha 에서는 앞서 본 메모리
배리어의 부재로 그 조정의 필요성 자체를 제거했습니다.


캐시 일관성 VS DMA
------------------

모든 시스템이 DMA 를 하는 디바이스에 대해서까지 캐시 일관성을 유지하지는
않습니다.  그런 경우, CMA 를 시도하는 디바이스는 RAM 으로부터 잘못된 데이터를
읽을 수도 있는데, 더티 캐시 라인이 여러 CPU 의 캐시에 머무르고 있고 아직 RAM 에
바뀐 값이 써지지 않았을 수 있기 때문입니다.  이 문제를 해결하기 위해선, 커널의
적절한 부분에서 각 CPU 캐시의 문제되는 비트들을 플러시 시켜야만 합니다 (그리고
그것들을 무효화 - invalidation - 도 시킬 수 있겠죠).

또한, 디바이스에 의해 RAM 에 DMA 로 쓰여진 값은 디바이스가 쓰기를 완료한 이후에
CPU 의 캐시에서 RAM 으로 쓰여지는 더티 캐시 라인에 의해 덮어써질 수도 있고, CPU
의 캐시에 존재하는 캐시 라인이 해당 캐시라인이 CPU 의 캐시에서 삭제되고 다시
값을 읽어들이기 전까지는 RAM 이 업데이트 되었다는 사실 자체를 숨겨버릴 수도
있습니다.  이 문제를 해결하기 위해선, 커널의 적절한 부분에서 각 CPU 의 캐시의
문제가 되는 비트들을 무효화 시켜야 합니다.

캐시 관리에 대한 더 많은 정보를 위해선 Documentation/cachetlb.txt 를
참고하세요.


캐시 일관성 VS MMIO
-------------------

Memory mapped I/O 는 일반적으로 CPU 의 메모리 공간 내의 한 윈도우의 부분에 있는
메모리 지역에 이루어지는데, 이 윈도우는 일반적인, RAM 으로 향하는 윈도우와는
다른 특성을 갖습니다.

그런 특성 가운데에는 일반적으로 그런 액세스는 캐시를 완전히 우회하고 디바이스
버스로 곧바로 향한다는 것입니다.  이 말은 MMIO 액세스는 먼저 이루어진 캐시된
메모리 액세스를 추월할 수 있다는 뜻입니다.  이런 경우엔 메모리 배리어만으로는
충분치 않고, 만약 캐시된 메모리 쓰기 오퍼레이션과 MMIO 액세스가 어떤 방식으로든
의존적이라면 해당 캐시는 두 오퍼레이션 사이에 비워져(flush)야만 합니다.


======================
CPU 들이 저지르는 일들
======================

프로그래머는 CPU 가 메모리 오퍼레이션들을 정확히 요청한대로 수행해 줄 것이라고
생각합니다, 따라서, 예를 들어 다음과 같은 코드를 실행하도록 CPU 에게 넘긴다면:

	a = READ_ONCE(*A);
	WRITE_ONCE(*B, b);
	c = READ_ONCE(*C);
	d = READ_ONCE(*D);
	WRITE_ONCE(*E, e);

CPU 는 각각의 인스트럭션을 위한 메모리 오퍼레이션을 다음 인스트럭션을 처리하기
전에 완료할 것이라 예상하고, 그로 인해 시스템 외부에서 관찰하기에 정해진 순서의
오퍼레이션이 수행될 것으로 예상합니다:

	LOAD *A, STORE *B, LOAD *C, LOAD *D, STORE *E.


당연하지만, 실제로는 훨씬 엉망입니다.  많은 CPU 들과 컴파일러들에서 앞의 가정은
성립하지 못하는데 그 이유는 다음과 같습니다:

 (*) 로드 오퍼레이션들은 실행을 계속 해나가기 위해 곧바로 완료될 필요가 있는
     경우가 많은 반면, 스토어 오퍼레이션들은 종종 별다른 문제 없이 유예될 수
     있습니다;

 (*) 로드 오퍼레이션들은 예측적으로 수행될 수도 있고, 필요없다고 증명된
     결과들은 버려져야 합니다;

 (*) 로드 오퍼레이션들은 예측적으로 수행될 수도 있으므로, 예상된 이벤트의
     시퀀스와 다른 시간에 실제 결과가 얻어질 수도 있습니다;

 (*) 메모리 액세스 순서들은 CPU 버스와 캐시를 좀 더 잘 사용할 수 있도록 재배열
     될수도 있습니다;

 (*) 로드와 스토어는 인접한 위치에의 액세스들을 일괄적으로 처리할 수 있는
     메모리나 I/O 하드웨어 (메모리와 PCI 디바이스 둘 다 이게 가능할 수도
     있습니다) 에 대해 요청되는 경우 개별 오퍼레이션을 위한 트랜잭션 설정
     비용을 아끼기 위해 조합될 수도 있습니다; 그리고

 (*) 해당 CPU 의 데이터 캐시가 순서에 영향을 끼칠 수도 있고, 캐시 일관성
     메커니즘이 - 스토어가 실제로 캐시에 도달한다면 - 이 문제를 완화시킬 수는
     있지만 이 일관성 관리가 다른 CPU 들에도 같은 순서로 전달된다는 보장은
     없습니다.

따라서 앞의 코드로부터 다른 CPU 가 볼수도 있는 결과는:

	LOAD *A, ..., LOAD {*C,*D}, STORE *E, STORE *B

	("LOAD {*C,*D}" 는 조합된 로드입니다)


하지만, CPU 는 스스로는 일관적일 것을 보장합니다: CPU 자기 _자신_ 의 액세스들은
자신에게는 메모리 배리어의 없이도 정확히 순서 세워진 것으로 보여질 것입니다.
예를 들어 다음의 코드가 주어졌다면:

	U = READ_ONCE(*A);
	WRITE_ONCE(*A, V);
	WRITE_ONCE(*A, W);
	X = READ_ONCE(*A);
	WRITE_ONCE(*A, Y);
	Z = READ_ONCE(*A);

그리고 외부의 영향에 의한 간섭이 없다고 가정하면, 최종 결과는 다음과 같이
나타날 것이라고 예상될 수 있습니다:

	U == *A 의 최초 값
	X == W
	Z == Y
	*A == Y

앞의 코드는 CPU 가 다음의 메모리 액세스 시퀀스를 만들도록 할겁니다:

	U=LOAD *A, STORE *A=V, STORE *A=W, X=LOAD *A, STORE *A=Y, Z=LOAD *A

하지만, 별다른 개입이 없다면, 이 시퀀스는 프로그램에 이 세상이 여전히
일관적이라고만 보인다는 보장 하에, 어떤 조합으로든 만들어질 수도 있으며, 각
액세스들은 합쳐지거나 버려질 수도 있습니다.  일부 아키텍쳐에서 CPU 는 같은
위치에 대한 연속적인 로드 오퍼레이션들을 재배치 할 수도 있기 때문에 READ_ONCE()
와 WRITE_ONCE() 는 이것을 막기 위해 뭐가 됐든 필요한 일을 하게 되는데, 예를
들어, Itanium 에서는 READ_ONCE() 와 WRITE_ONCE() 를 이용한 volatile 캐스팅은
GCC 가 각각 그런 재배치를 방지하는 특수 인스트럭션인 ld.acq 와 stl.rel
인스트럭션을 각각 만들도록 합니다.

컴파일러 역시 시퀀스의 액세스들을 CPU 가 보기도 전에 합치거나 버리거나 뒤로
미뤄버릴 수 있습니다.

예를 들어:

	*A = V;
	*A = W;

는 다음과 같이 변형될 수 있습니다:

	*A = W;

따라서, 쓰기 배리어나 WRITE_ONCE() 없이는, *A 로의 V 값의 저장의 효과는
사라진다고 가정할 수 있습니다.  비슷하게:

	*A = Y;
	Z = *A;

는, 메모리 배리어나 READ_ONCE() 와 WRITE_ONCE() 없이는 다음과 같이 변형될 수
있습니다:

	*A = Y;
	Z = Y;

그리고 이 LOAD 오퍼레이션은 CPU 바깥에는 아예 보이지 않습니다.


그리고 ALPHA 가 있다
--------------------

DEC Alpha CPU 는 가장 완화된 메모리 순서의 CPU 중 하나입니다.  그것뿐만 아니라,
Alpha CPU 의 일부 버전은 분할된 데이터 캐시를 가지고 있어서, 두개의 의미적으로
관계되어 있는 캐시 라인이 서로 다른 시간에 업데이트 되는 것도 허용합니다.
여기가 바로 데이터 의존성 배리어가 정말 필요해 지는 부분인데, 데이터 의존성
배리어는 메모리 일관성 시스템과 함께 두개 캐시 모두를 동기화 해서, 포인터 변경
과 새로운 데이터 발견을 올바른 순서로 일어나게 하기 때문입니다.

Alpha 로 리눅스 커널의 메모리 배리어 모델을 정의할 수 있습니다.

위의 "캐시 일관성" 서브섹션을 참고하세요.


가상 머신 게스트
----------------

가상 머신에서 동작하는 게스트들은 게스트 자체는 SMP 지원 없이 컴파일 되었다
해도 SMP 영향을 받을 수 있습니다.  이건 UP 커널을 사용하면서 SMP 호스트와
결부되어 발생하는 부작용입니다.  이 경우에는 필수 배리어를 사용해서 문제를
해결할 수 있겠지만 그런 방법은 대부분의 경우 최적의 해결법은 아닙니다.

이 경우를 완벽하게 해결하기 위해, 로우 레벨의 virt_mb() 등의 매크로를 사용할 수
있습니다. 이것들은 SMP 가 활성화 되어 있다면 smp_mb() 등과 동일한 효과를
갖습니다만, SMP 와 SMP 아닌 시스템 모두에 대해 동일한 코드를 만들어냅니다.
예를 들어, 가상 머신 게스트들은 (아마도 SMP 일) 호스트와 동기화를 할 때에는
smp_mb() 가 아니라 virt_mb() 를 사용해야 합니다.

이것들은 smp_mb() 류의 것들과 모든 부분에서 동일하며, 특히, MMIO 의 영향에
대해서는 간여하지 않습니다: MMIO 의 영향을 제어하려면, 필수 배리어들을
사용하시기 바랍니다.


=======
사용 예
=======

순환식 버퍼
-----------

메모리 배리어들은 순환식 버퍼를 생성자와 소비자 사이의 동기화에 락을 사용하지
않고 구현하는데 사용될 수 있습니다.  더 자세한 내용을 위해선 다음을 참고하세요:

	Documentation/circular-buffers.txt


=========
참고 문헌
=========

Alpha AXP Architecture Reference Manual, Second Edition (Sites & Witek,
Digital Press)
	Chapter 5.2: Physical Address Space Characteristics
	Chapter 5.4: Caches and Write Buffers
	Chapter 5.5: Data Sharing
	Chapter 5.6: Read/Write Ordering

AMD64 Architecture Programmer's Manual Volume 2: System Programming
	Chapter 7.1: Memory-Access Ordering
	Chapter 7.4: Buffering and Combining Memory Writes

IA-32 Intel Architecture Software Developer's Manual, Volume 3:
System Programming Guide
	Chapter 7.1: Locked Atomic Operations
	Chapter 7.2: Memory Ordering
	Chapter 7.4: Serializing Instructions

The SPARC Architecture Manual, Version 9
	Chapter 8: Memory Models
	Appendix D: Formal Specification of the Memory Models
	Appendix J: Programming with the Memory Models

UltraSPARC Programmer Reference Manual
	Chapter 5: Memory Accesses and Cacheability
	Chapter 15: Sparc-V9 Memory Models

UltraSPARC III Cu User's Manual
	Chapter 9: Memory Models

UltraSPARC IIIi Processor User's Manual
	Chapter 8: Memory Models

UltraSPARC Architecture 2005
	Chapter 9: Memory
	Appendix D: Formal Specifications of the Memory Models

UltraSPARC T1 Supplement to the UltraSPARC Architecture 2005
	Chapter 8: Memory Models
	Appendix F: Caches and Cache Coherency

Solaris Internals, Core Kernel Architecture, p63-68:
	Chapter 3.3: Hardware Considerations for Locks and
			Synchronization

Unix Systems for Modern Architectures, Symmetric Multiprocessing and Caching
for Kernel Programmers:
	Chapter 13: Other Memory Models

Intel Itanium Architecture Software Developer's Manual: Volume 1:
	Section 2.6: Speculation
	Section 4.4: Memory Access
